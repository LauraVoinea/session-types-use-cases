@misc{fowler:bsc,
    author = {Fowler, Simon},
    citeulike-article-id = {13882787},
    howpublished = {BSc dissertation},
    keywords = {dependent-types, my-papers},
    month = apr,
    posted-at = {2015-12-13 17:36:08},
    priority = {0},
    title = {{Verified Networking using Dependent Types}},
    year = {2014}
}

@mastersthesis{fowler:msc,
    author = {Fowler, Simon},
    citeulike-article-id = {13882782},
    institution = {University of Edinburgh},
    keywords = {el-bastardo, erlang, multiparty-session-types, my-papers, session-types},
    month = aug,
    posted-at = {2015-12-13 17:20:30},
    priority = {0},
    title = {Monitoring {Erlang/OTP} Applications using Multiparty Session Types},
    year = {2015}
}

@misc{franco:numa,
    author = {Franco, Juliana and Drossopoulou, Sophia},
    citeulike-article-id = {13763867},
    howpublished = {Pre-proceeedings of the 8th International Workshop on Programming Language Approaches to Concurrency- and Communication-cEntric Software},
    keywords = {behavioural-types, session-actors, session-types},
    posted-at = {2015-09-14 19:59:14},
    priority = {0},
    title = {Behavioural types for non-uniform memory accesses},
    year = {2015}
}

@article{strom:typestate,
    author = {Strom, Robert E. and Yemini, Shaula},
    citeulike-article-id = {13763664},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/tse.1986.6312929},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=6312929},
    doi = {10.1109/tse.1986.6312929},
    institution = {IBM Thomas J. Watson Res. Center, Yorktown Heights, NY, USA},
    issn = {0098-5589},
    journal = {Software Engineering, IEEE Transactions on},
    keywords = {typestate},
    month = jan,
    number = {1},
    pages = {157--171},
    posted-at = {2015-09-14 14:43:26},
    priority = {1},
    publisher = {IEEE},
    title = {Typestate: A programming language concept for enhancing software reliability},
    url = {http://dx.doi.org/10.1109/tse.1986.6312929},
    volume = {SE-12},
    year = {1986}
}

@inproceedings{lindley:corelinks,
    address = {New York, NY, USA},
    author = {Lindley, Sam and Cheney, James},
    booktitle = {Proceedings of the 8th ACM SIGPLAN Workshop on Types in Language Design and Implementation},
    citeulike-article-id = {13763103},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/2103786.2103798},
    citeulike-linkout-1 = {http://doi.acm.org/10.1145/2103786.2103798},
    doi = {10.1145/2103786.2103798},
    keywords = {effect, functional-programming, integrated, language, links, normalisation, polymorphism, query, row, types},
    location = {Philadelphia, Pennsylvania, USA},
    pages = {91--102},
    posted-at = {2015-09-13 20:11:01},
    priority = {5},
    publisher = {ACM},
    series = {TLDI '12},
    title = {Row-based Effect Types for Database Integration},
    url = {http://doi.acm.org/10.1145/2103786.2103798},
    year = {2012}
}

@misc{lindley:lightweight,
    author = {Lindley, Sam and Morris, J. Garrett},
    citeulike-article-id = {13763102},
    howpublished = {Unpublished draft},
    keywords = {functional-programming, session-types},
    posted-at = {2015-09-13 20:08:21},
    priority = {0},
    title = {{Lightweight Functional Session Types}},
    year = {2015}
}

@article{lindley:idioms-oblivious,
    abstract = {We revisit the connection between three notions of computation: Moggi\^{E}¼s monads, Hughes\^{E}¼s arrows and {McBride} and Paterson\^{E}¼s idioms (also called applicative functors  ). We show that idioms are equivalent to arrows that satisfy the type isomorphism {A\^{a}B\^{a}}{1\^{a}(A}→{B)A\^{a}}{B\^{a}1\^{a}(A}→B) and that monads are equivalent to arrows that satisfy the type isomorphism {A\^{a}B\^{a}}{A→(1\^{a}B}){A\^{a}B\^{a}}{A→(1\^{a}B}). Further, idioms embed into arrows and arrows embed into monads.},
    author = {Lindley, Sam and Wadler, Philip and Yallop, Jeremy},
    citeulike-article-id = {8959920},
    citeulike-linkout-0 = {http://dx.doi.org/10.1016/j.entcs.2011.02.018},
    day = {08},
    doi = {10.1016/j.entcs.2011.02.018},
    issn = {15710661},
    journal = {Electronic Notes in Theoretical Computer Science},
    keywords = {functional-abstractions, idioms},
    month = mar,
    number = {5},
    pages = {97--117},
    posted-at = {2015-09-07 22:09:28},
    priority = {2},
    title = {Idioms are Oblivious, Arrows are Meticulous, Monads are Promiscuous},
    url = {http://dx.doi.org/10.1016/j.entcs.2011.02.018},
    volume = {229},
    year = {2011}
}

@inproceedings{ploeg:frpnow,
    address = {New York, NY, USA},
    author = {Ploeg, Atze and Claessen, Koen},
    booktitle = {Proceedings of the 20th ACM SIGPLAN International Conference on Functional Programming},
    citeulike-article-id = {13754486},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/2784731.2784752},
    citeulike-linkout-1 = {http://doi.acm.org/10.1145/2784731.2784752},
    doi = {10.1145/2784731.2784752},
    keywords = {functional, functional-programming, functional-reactive-programming, io, kripke, logical, programming, purely, reactive, relations, space-leak},
    location = {Vancouver, BC, Canada},
    pages = {302--314},
    posted-at = {2015-09-07 13:10:18},
    priority = {2},
    publisher = {ACM},
    series = {ICFP 2015},
    title = {Practical Principled {FRP}: Forget the Past, Change the Future, {FRPNow}!},
    url = {http://doi.acm.org/10.1145/2784731.2784752},
    year = {2015}
}

@phdthesis{lijnse:top-rescue,
    author = {Lijnse, Bas},
    citeulike-article-id = {13753698},
    howpublished = {Radboud University Nijmegen},
    keywords = {task-oriented-programming},
    posted-at = {2015-09-06 15:50:57},
    priority = {2},
    title = {{TOP to the Rescue---Task-Oriented Programming for Incident Response Applications}}
}

@book{snoyman:yesod,
    address = {Sebastopol, CA.},
    author = {Snoyman, Michael},
    citeulike-article-id = {13753633},
    editor = {St. Laurent, Simon},
    keywords = {haskell, web-abstractions, web-programming},
    posted-at = {2015-09-06 12:12:14},
    priority = {2},
    publisher = {O'Reilly Media, Inc.},
    title = {{Developing Web Applications with Haskell and Yesod}},
    year = {2012}
}

@inproceedings{lange:choreographies,
    abstract = {Graphical choreographies, or global graphs, are general multiparty session specifications featuring expressive constructs such as forking, merging, and joining for representing application-level protocols. Global graphs can be directly translated into modelling notations such as {BPMN} and {UML}. This paper presents an algorithm whereby a global graph can be constructed from asynchronous interactions represented by communicating finite-state machines ({CFSMs}). Our results include: a sound and complete characterisation of a subset of safe {CFSMs} from which global graphs can be constructed; an algorithm to translate {CFSMs} to global graphs; a time complexity analysis; and an implementation of our theory, as well as an experimental evaluation.},
    address = {New York, NY, USA},
    author = {Lange, Julien and Tuosto, Emilio and Yoshida, Nobuko},
    booktitle = {Proceedings of the 42Nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    citeulike-article-id = {13708364},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2676964},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2676726.2676964},
    doi = {10.1145/2676726.2676964},
    isbn = {978-1-4503-3300-9},
    location = {Mumbai, India},
    pages = {221--232},
    posted-at = {2015-08-21 08:43:57},
    priority = {2},
    publisher = {ACM},
    series = {POPL '15},
    title = {From Communicating Machines to Graphical Choreographies},
    url = {http://dx.doi.org/10.1145/2676726.2676964},
    year = {2015}
}

@article{benton:exceptions,
    abstract = {From the points of view of programming pragmatics, rewriting and operational semantics, the syntactic construct used for exception handling in {ML}-like programming languages, and in much theoretical work on exceptions, has subtly undesirable features. We propose and discuss a more well-behaved construct.},
    author = {Benton, Nick and Kennedy, Andrew},
    citeulike-article-id = {13707269},
    citeulike-linkout-0 = {http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=83909},
    citeulike-linkout-1 = {http://dx.doi.org/10.1017/s0956796801004099},
    doi = {10.1017/s0956796801004099},
    issn = {1469-7653},
    journal = {Journal of Functional Programming},
    keywords = {exceptions, ml},
    pages = {395--410},
    posted-at = {2015-08-21 03:41:01},
    priority = {2},
    title = {Exceptional syntax},
    url = {http://dx.doi.org/10.1017/s0956796801004099},
    volume = {11},
    year = {2001}
}

@inproceedings{chlipala:urweb,
    address = {New York, NY, USA},
    author = {Chlipala, Adam},
    booktitle = {Proceedings of the 31st ACM SIGPLAN Conference on Programming Language Design and Implementation},
    citeulike-article-id = {13703619},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/1806596.1806612},
    citeulike-linkout-1 = {http://doi.acm.org/10.1145/1806596.1806612},
    doi = {10.1145/1806596.1806612},
    keywords = {dependent, dependent-types, metaprogramming, types, web-programming},
    location = {Toronto, Ontario, Canada},
    pages = {122--133},
    posted-at = {2015-08-16 03:21:56},
    priority = {2},
    publisher = {ACM},
    series = {PLDI '10},
    title = {{Ur: Statically-typed Metaprogramming with Type-level Record Computation}},
    url = {http://doi.acm.org/10.1145/1806596.1806612},
    year = {2010}
}

@incollection{fowler:ui-next,
    abstract = {Modern web applications are heavily dynamic. Several approaches, including functional reactive programming and data binding, allow a presentation layer to automatically reflect changes in a data layer. However, many of these techniques are prone to unpredictable memory performance, do not make guarantees about node identity, or cannot easily express dynamism in the dataflow graph.

                            We identify a point in the design space for the creation of statically-typed, reactive, dynamic, single-page web applications for the {WebSharper} framework in the functional-first language F\#. We provide an embedding abstraction to link a dynamic dataflow graph to a {DOM} presentation layer in order to implement dynamic single-page applications, and show how the technique can be used to support declarative animation.},
    author = {Fowler, Simon and Denuzi\`{e}re, Lo\"{i}c and Granicz, Adam},
    booktitle = {Practical Aspects of Declarative Languages},
    citeulike-article-id = {13703594},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-319-19686-2_5},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-319-19686-2_5},
    doi = {10.1007/978-3-319-19686-2_5},
    editor = {Pontelli, Enrico and Son, Tran C.},
    keywords = {my-papers, ui-next, web, websharper},
    pages = {58--73},
    posted-at = {2015-08-15 23:18:12},
    priority = {0},
    publisher = {Springer International Publishing},
    series = {Lecture Notes in Computer Science},
    title = {{Reactive Single-Page Applications with Dynamic Dataflow}},
    url = {http://dx.doi.org/10.1007/978-3-319-19686-2_5},
    volume = {9131},
    year = {2015}
}

@inproceedings{claessen:semantics,
    abstract = {We propose an extension to Fredlund's formal semantics for Erlang that models the concept of nodes. The motivation is that there exist sequences of events that can occur in practice, but are impossible to describe using a single-node semantics, such as Fredlund's. The consequence is that some errors in distributed systems might not be detected by model checkers based on Fredlund's original semantics, or by other single-node verification techniques such as testing. Our extension is modest; it re-uses most of Fredlund's work but adds an extra layer at the top-level.},
    address = {New York, NY, USA},
    author = {Claessen, Koen and Svensson, Hans},
    booktitle = {Proceedings of the 2005 ACM SIGPLAN Workshop on Erlang},
    citeulike-article-id = {13700946},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1088376},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1088361.1088376},
    doi = {10.1145/1088361.1088376},
    isbn = {1-59593-066-3},
    keywords = {erlang, semantics},
    location = {Tallinn, Estonia},
    pages = {78--87},
    posted-at = {2015-08-13 10:48:16},
    priority = {2},
    publisher = {ACM},
    series = {ERLANG '05},
    title = {A Semantics for Distributed Erlang},
    url = {http://dx.doi.org/10.1145/1088361.1088376},
    year = {2005}
}

@inproceedings{svensson:semantics,
    author = {Svensson, Hans and Fredlund, Lars-Ake},
    booktitle = {Erlang Workshop},
    citeulike-article-id = {13700945},
    keywords = {erlang, semantics},
    organization = {Citeseer},
    pages = {43--54},
    posted-at = {2015-08-12 23:26:31},
    priority = {2},
    title = {A more accurate semantics for distributed {E}rlang},
    year = {2007}
}

@unpublished{scribblespec,
    author = {{The Scribble Team}},
    citeulike-article-id = {13697875},
    keywords = {scribble},
    note = {\url{http://www.doc.ic.ac.uk/\~{}rhu/scribble/langref.html}},
    posted-at = {2015-08-08 20:32:29},
    priority = {2},
    title = {{Scribble Language Reference}},
    year = {2013}
}

@unpublished{neykova:actors-journal,
    author = {Neykova, Rumyana and Yoshida, Nobuko},
    citeulike-article-id = {13697861},
    note = {Extended journal version. Under submission.},
    posted-at = {2015-08-08 20:06:30},
    priority = {2},
    title = {{Multiparty Session Actors}}
}

@book{sangiorgi:pi-calc,
    address = {New York, NY, USA},
    author = {Sangiorgi, Davide and Walker, David},
    citeulike-article-id = {13697758},
    keywords = {pi-calculus},
    posted-at = {2015-08-08 17:13:07},
    priority = {2},
    publisher = {Cambridge University Press},
    title = {{PI}-Calculus: A Theory of Mobile Processes},
    year = {2001}
}

@incollection{agha:actor-pi,
    abstract = {The development of Simula by {Ole-Johan} Dahl and Kristen Nygaard introduced a number of important programming language concepts – object which supports modularity in programming through encapsulation of data and procedures, the concept of class which organizes behavior and supports Abstract Data Types, and the concept inheritance which provides subtyping relations and reuse [6]. Peter Wegner terms programming languages which use objects as object-based languages, and reserves the term object-oriented languages for languages which also support classes and inheritance [58].},
    address = {Berlin, Heidelberg},
    author = {Agha, Gul and Thati, Prasanna},
    booktitle = {From Object-Orientation to Formal Methods},
    chapter = {4},
    citeulike-article-id = {1178992},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-540-39993-3_4},
    citeulike-linkout-1 = {http://www.springerlink.com/content/hf8leqm1fgrxwbvm},
    citeulike-linkout-2 = {http://link.springer.com/chapter/10.1007/978-3-540-39993-3_4},
    doi = {10.1007/978-3-540-39993-3_4},
    editor = {Owe, Olaf and Krogdahl, Stein and Lyche, Tom},
    isbn = {978-3-540-21366-6},
    journal = {: From Object-Orientation to Formal Methods},
    keywords = {actors, agha, process-calculi},
    pages = {26--57},
    posted-at = {2015-08-03 00:28:07},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {An Algebraic Theory of Actors and Its Application to a Simple {Object-Based} Language},
    url = {http://dx.doi.org/10.1007/978-3-540-39993-3_4},
    volume = {2635},
    year = {2004}
}

@article{crafa:actors,
    archivePrefix = {arXiv},
    author = {Crafa, Silvia},
    citeulike-article-id = {13687896},
    citeulike-linkout-0 = {http://arxiv.org/abs/1206.1687},
    eprint = {1206.1687},
    journal = {CoRR},
    keywords = {actors, behavioural-types},
    posted-at = {2015-07-28 16:30:28},
    priority = {2},
    title = {Behavioural Types for Actor Systems},
    url = {http://arxiv.org/abs/1206.1687},
    volume = {abs/1206.1687},
    year = {2012}
}

@inproceedings{lindahl:success-typings,
    abstract = {In languages where the compiler performs no static type checks, many programs never go wrong, but the intended use of functions and component interfaces is often undocumented or appears only in the form of comments which cannot always be trusted. This often makes program maintenance problematic. We show that it is possible to reconstruct a significant portion of the type information which is implicit in a program, automatically annotate function interfaces, and detect definite type clashes without fundamental changes to the philosophy of the language or imposing a type system which unnecessarily rejects perfectly reasonable programs. To do so, we introduce the notion of success typings of functions. Unlike most static type systems, success typings incorporate subtyping and never disallow a use of a function that will not result in a type clash during runtime. Unlike most soft typing systems that have previously been proposed, success typings allow for compositional, bottom-up type inference which appears to scale well in practice. Moreover, by taking control-flow into account and exploiting properties of the language such as its module system, success typings can be refined and become accurate and precise We demonstrate the power and practicality of the approach by applying it to Erlang. We report on our experiences from employing the type inference algorithm, without any guidance, on programs of significant size},
    address = {New York, NY, USA},
    author = {Lindahl, Tobias and Sagonas, Konstantinos},
    booktitle = {Proceedings of the 8th ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming},
    citeulike-article-id = {7085026},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1140335.1140356},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1140335.1140356},
    doi = {10.1145/1140335.1140356},
    isbn = {1-59593-388-3},
    keywords = {erlang, type-inference},
    location = {Venice, Italy},
    pages = {167--178},
    posted-at = {2015-07-28 13:45:06},
    priority = {2},
    publisher = {ACM},
    series = {PPDP '06},
    title = {Practical Type Inference Based on Success Typings},
    url = {http://dx.doi.org/10.1145/1140335.1140356},
    year = {2006}
}

@inproceedings{hewitt:actors,
    abstract = {This paper proposes a modular {ACTOR} architecture and definitional method for artificial intelligence that is conceptually based on a single kind of object: actors [or, if you will, virtual processors, activation frames, or streams]. The formalism makes no presuppositions about the representation of primitive data structures and control structures. Such structures can be programmed, micro-coded, or hard wired in a uniform modular fashion. In fact it is impossible to determine whether a given object is "really" represented as a list, a vector, a hash table, a function, or a process. The architecture will efficiently run the coming generation of {PLANNER}-like artificial intelligence languages including those requiring a high degree of parallelism. The efficiency is gained without loss of programming generality because it only makes certain actors more efficient; it does not change their behavioral characteristics. The architecture is general with respect to control structure and does not have or need goto, interrupt, or semaphore primitives. The formalism achieves the goals that the disallowed constructs are intended to achieve by other more structured methods.},
    address = {San Francisco, CA, USA},
    author = {Hewitt, Carl and Bishop, Peter and Steiger, Richard},
    booktitle = {Proceedings of the 3rd International Joint Conference on Artificial Intelligence},
    citeulike-article-id = {6238417},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1624804},
    keywords = {actors},
    location = {Stanford, USA},
    pages = {235--245},
    posted-at = {2015-07-28 12:25:55},
    priority = {2},
    publisher = {Morgan Kaufmann Publishers Inc.},
    series = {IJCAI'73},
    title = {A Universal Modular {ACTOR} Formalism for Artificial Intelligence},
    url = {http://portal.acm.org/citation.cfm?id=1624804},
    year = {1973}
}

@inproceedings{colombo:larva,
    author = {Colombo, Christian and Pace, Gordon J. and Schneider, Gerardo},
    booktitle = {Software Engineering and Formal Methods, 2009 Seventh IEEE International Conference on},
    citeulike-article-id = {13687675},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/sefm.2009.13},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5368053},
    doi = {10.1109/sefm.2009.13},
    institution = {Dept. of Comput. Sci., Univ. of Malta, Msida, Malta},
    isbn = {978-0-7695-3870-9},
    keywords = {dynamic-monitoring, java, monitoring},
    month = nov,
    pages = {33--37},
    posted-at = {2015-07-28 11:33:29},
    priority = {1},
    publisher = {IEEE},
    title = {{LARVA} --- Safer Monitoring of {Real-Time} Java Programs (Tool Paper)},
    url = {http://dx.doi.org/10.1109/sefm.2009.13},
    year = {2009}
}

@incollection{francalanza:elarva,
    abstract = {The Larva monitoring tool has been successfully applied to a number of industrial Java systems, providing extra assurance of behaviour correctness. Given the increased interest in concurrent programming, we propose Elarva, an adaptation of Larva for monitoring programs written in Erlang, an established industry-strength concurrent language. Object-oriented Larva constructs have been translated to process-oriented setting, and the synchronous Larva monitoring semantics was altered to an asynchronous interpretation. We argue how this loosely-coupled runtime verification architecture still permits monitors to actuate recovery actions.},
    author = {Colombo, Christian and Francalanza, Adrian and Gatt, Rudolph},
    booktitle = {Runtime Verification},
    citeulike-article-id = {13687662},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-29860-8_29},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-29860-8_29},
    doi = {10.1007/978-3-642-29860-8_29},
    editor = {Khurshid, Sarfraz and Sen, Koushik},
    keywords = {dynamic-monitoring, erlang, monitoring},
    pages = {370--374},
    posted-at = {2015-07-28 11:25:36},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Elarva: A Monitoring Tool for Erlang},
    url = {http://dx.doi.org/10.1007/978-3-642-29860-8_29},
    volume = {7186},
    year = {2012}
}

@article{carbone:web-services,
    address = {New York, NY, USA},
    author = {Carbone, Marco and Honda, Kohei and Yoshida, Nobuko},
    citeulike-article-id = {13682584},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/2220365.2220367},
    citeulike-linkout-1 = {http://doi.acm.org/10.1145/2220365.2220367},
    doi = {10.1145/2220365.2220367},
    journal = {ACM Trans. Program. Lang. Syst.},
    keywords = {calculi, choreography, communication, end-point, mergeability, multiparty-session-types, process, projection, services, session, session-types, system, type, types, web},
    month = jun,
    number = {2},
    posted-at = {2015-07-23 22:37:14},
    priority = {2},
    publisher = {ACM},
    title = {Structured {Communication-Centered} Programming for Web Services},
    url = {http://doi.acm.org/10.1145/2220365.2220367},
    volume = {34},
    year = {2012}
}

@article{neykova:timed,
    author = {Neykova, Rumyana and Bocchi, Laura and Yoshida, Nobuko},
    citeulike-article-id = {13674624},
    journal = {arXiv preprint arXiv:1408.5979},
    keywords = {multiparty-session-types, session-types, timed-session-types},
    posted-at = {2015-07-16 16:00:42},
    priority = {2},
    title = {Timed runtime monitoring for multiparty conversations},
    year = {2014}
}

@inproceedings{bocchi:deadlines,
    author = {Bocchi, L. and Lange, J. and Yoshida, N.},
    booktitle = {CONCUR 2015---Concurrency Theory},
    citeulike-article-id = {13674618},
    howpublished = {To appear},
    keywords = {multiparty-session-types, timed-session-types},
    posted-at = {2015-07-16 15:52:26},
    priority = {2},
    title = {{Meeting Deadlines Together}},
    year = {2015}
}

@incollection{bocchi:timed,
    author = {Bocchi, Laura and Yang, Weizhen and Yoshida, Nobuko},
    booktitle = {CONCUR 2014--Concurrency Theory},
    citeulike-article-id = {13674616},
    keywords = {session-types, timed-session-types},
    pages = {419--434},
    posted-at = {2015-07-16 15:48:01},
    priority = {2},
    publisher = {Springer},
    title = {Timed multiparty session types},
    year = {2014}
}

@article{bpmn:examples,
    author = {Bpmn, Omg},
    citeulike-article-id = {13674521},
    howpublished = {\\url{http://www.omg.org/spec/BPMN/2.0/examples/PDF}},
    journal = {OMG Document Number: dtc/2010-06-02},
    keywords = {bpmn},
    posted-at = {2015-07-16 13:08:07},
    priority = {2},
    title = {{BPMN 2.0 by Example}},
    year = {2010}
}

@inproceedings{wiger:gproc,
    address = {New York, NY, USA},
    author = {Wiger, Ulf T.},
    booktitle = {Proceedings of the 2007 SIGPLAN Workshop on ERLANG Workshop},
    citeulike-article-id = {13662316},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/1292520.1292522},
    citeulike-linkout-1 = {http://doi.acm.org/10.1145/1292520.1292522},
    doi = {10.1145/1292520.1292522},
    keywords = {erlang, process, registry},
    location = {Freiburg, Germany},
    pages = {1--10},
    posted-at = {2015-07-01 17:22:39},
    priority = {2},
    publisher = {ACM},
    series = {ERLANG '07},
    title = {{Extended Process Registry for Erlang}},
    url = {http://doi.acm.org/10.1145/1292520.1292522},
    year = {2007}
}

@inproceedings{dardha:revisited,
    author = {Dardha, Ornela and Giachino, Elena and Sangiorgi, Davide},
    booktitle = {Proceedings of the 14th symposium on Principles and practice of declarative programming},
    citeulike-article-id = {13657060},
    keywords = {pi-calculus, session-types},
    organization = {ACM},
    pages = {139--150},
    posted-at = {2015-06-26 01:19:36},
    priority = {2},
    title = {Session types revisited},
    year = {2012}
}

@incollection{kobayashi:translation,
    author = {Kobayashi, Naoki},
    booktitle = {Formal Methods at the Crossroads. From Panacea to Foundational Support},
    citeulike-article-id = {13657059},
    keywords = {pi-calculus},
    pages = {439--453},
    posted-at = {2015-06-26 01:17:19},
    priority = {2},
    publisher = {Springer},
    title = {Type systems for concurrent programs},
    year = {2003}
}

@article{coppo:global-progress,
    author = {Coppo, Mario and Dezani-Ciancaglini, Mariangiola and Yoshida, Nobuko and Padovani, Luca},
    citeulike-article-id = {13657056},
    journal = {Mathematical Structures in Computer Science},
    keywords = {multiparty-session-types, session-types},
    pages = {1--65},
    posted-at = {2015-06-26 01:12:29},
    priority = {2},
    publisher = {Cambridge Univ Press},
    title = {Global progress for dynamically interleaved multiparty sessions},
    year = {2015}
}

@incollection{bettini:global-progress,
    author = {Bettini, Lorenzo and Coppo, Mario and D'Antoni, Loris and De Luca, Marco and Dezani-Ciancaglini, Mariangiola and Yoshida, Nobuko},
    booktitle = {CONCUR 2008-Concurrency Theory},
    citeulike-article-id = {13657055},
    keywords = {multiparty-session-types, session-types},
    pages = {418--433},
    posted-at = {2015-06-26 01:11:54},
    priority = {2},
    publisher = {Springer},
    title = {Global progress in dynamically interleaved multiparty sessions},
    year = {2008}
}

@article{kobayashi:linearity,
    author = {Kobayashi, Naoki and Pierce, Benjamin C. and Turner, David N.},
    citeulike-article-id = {13657054},
    journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
    keywords = {linearity, pi-calculus},
    number = {5},
    pages = {914--947},
    posted-at = {2015-06-26 01:10:06},
    priority = {2},
    publisher = {ACM},
    title = {Linearity and the pi-calculus},
    volume = {21},
    year = {1999}
}

@incollection{demangeon:subsessions,
    author = {Demangeon, Romain and Honda, Kohei},
    booktitle = {CONCUR 2012---Concurrency Theory},
    citeulike-article-id = {13656977},
    keywords = {session-types, subsessions},
    pages = {272--286},
    posted-at = {2015-06-25 21:07:01},
    priority = {2},
    publisher = {Springer},
    title = {Nested {P}rotocols in {S}ession {T}ypes},
    year = {2012}
}

@phdthesis{armstrong:thesis,
    author = {Armstrong, Joe},
    citeulike-article-id = {13656975},
    keywords = {distributed-systems, erlang, failure-handling},
    posted-at = {2015-06-25 21:05:40},
    priority = {2},
    school = {The Royal Institute of Technology Stockholm, Sweden},
    title = {Making {R}eliable {D}istributed {S}ystems in the {P}resence of {S}oftware {E}rrors},
    year = {2003}
}

@article{armstrong:erlang,
    author = {Armstrong, Joe},
    citeulike-article-id = {13656974},
    journal = {Communications of the ACM},
    keywords = {erlang},
    number = {9},
    pages = {68--75},
    posted-at = {2015-06-25 21:04:40},
    priority = {2},
    publisher = {ACM},
    title = {{E}rlang},
    volume = {53},
    year = {2010}
}

@article{wright:syntactic,
    author = {Wright, Andrew K. and Felleisen, Matthias},
    citeulike-article-id = {13656960},
    journal = {Information and computation},
    keywords = {evaluation-contexts, type-soundness},
    number = {1},
    pages = {38--94},
    posted-at = {2015-06-25 20:44:58},
    priority = {2},
    publisher = {Elsevier},
    title = {A {S}yntactic {A}pproach to {T}ype {S}oundness},
    volume = {115},
    year = {1994}
}

@incollection{bocchi:design-by-contract,
    author = {Bocchi, Laura and Honda, Kohei and Tuosto, Emilio and Yoshida, Nobuko},
    booktitle = {CONCUR 2010-Concurrency Theory},
    citeulike-article-id = {13656958},
    keywords = {design-by-contract, session-types},
    pages = {162--176},
    posted-at = {2015-06-25 20:41:24},
    priority = {2},
    publisher = {Springer},
    title = {A theory of design-by-contract for distributed multiparty interactions},
    year = {2010}
}

@inproceedings{mazurak:lightweight,
    author = {Mazurak, Karl and Zhao, Jianzhou and Zdancewic, Steve},
    booktitle = {Proceedings of the 5th ACM SIGPLAN workshop on Types in language design and implementation},
    citeulike-article-id = {13656952},
    keywords = {linear-types},
    organization = {ACM},
    pages = {77--88},
    posted-at = {2015-06-25 20:17:15},
    priority = {2},
    title = {Lightweight {L}inear {T}ypes in {S}ystem {F}},
    year = {2010}
}

@inproceedings{levy:explicit-substitutions,
    author = {L{\'{e}}vy, Jean-Jacques and Maranget, Luc},
    booktitle = {Foundations of Software Technology and Theoretical Computer Science},
    citeulike-article-id = {13656950},
    keywords = {logic, programming-languages},
    organization = {Springer},
    pages = {181--200},
    posted-at = {2015-06-25 20:02:04},
    priority = {2},
    title = {Explicit substitutions and programming languages},
    year = {1999}
}

@incollection{lindley:semantics,
    author = {Lindley, Sam and Morris, J. Garrett},
    booktitle = {Programming Languages and Systems},
    citeulike-article-id = {13656947},
    keywords = {edinburgh, linear-logic, session-types},
    pages = {560--584},
    posted-at = {2015-06-25 19:56:08},
    priority = {0},
    publisher = {Springer},
    title = {A {S}emantics for {P}ropositions as {S}essions},
    year = {2015}
}

@article{brand:cfsms,
    author = {Brand, Daniel and Zafiropulo, Pitro},
    citeulike-article-id = {13654961},
    journal = {Journal of the ACM (JACM)},
    keywords = {communicating-automata},
    number = {2},
    pages = {323--342},
    posted-at = {2015-06-24 11:00:23},
    priority = {2},
    publisher = {ACM},
    title = {On communicating finite-state machines},
    volume = {30},
    year = {1983}
}

@inproceedings{elsman:smltojs,
    author = {Elsman, Martin},
    booktitle = {Proceedings of the 1st ACM SIGPLAN international workshop on Programming language and systems technologies for internet clients},
    citeulike-article-id = {13582876},
    keywords = {javascript},
    organization = {ACM},
    pages = {39--48},
    posted-at = {2015-04-15 19:08:13},
    priority = {2},
    title = {{SMLtoJs: Hosting a Standard ML Compiler in a Web Browser}},
    year = {2011}
}

@incollection{syme:asynchronous,
    abstract = {We describe the asynchronous programming model in F\#, and its applications to reactive, parallel and concurrent programming. The key feature combines a core language with a non-blocking modality to author lightweight asynchronous tasks, where the modality has control flow constructs that are syntactically a superset of the core language and are given an asynchronous semantic interpretation. This allows smooth transitions between synchronous and asynchronous code and eliminates callback-style treatments of inversion of control, without disturbing the foundation of {CPU}-intensive programming that allows F\# to interoperate smoothly and compile efficiently. An adapted version of this approach has recently been announced for a future version of C\#.},
    address = {Berlin, Heidelberg},
    author = {Syme, Don and Petricek, Tomas and Lomov, Dmitry},
    booktitle = {Practical Aspects of Declarative Languages},
    chapter = {15},
    citeulike-article-id = {10477806},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-18378-2_15},
    citeulike-linkout-1 = {http://www.springerlink.com/content/h224703352375305},
    citeulike-linkout-2 = {http://link.springer.com/chapter/10.1007/978-3-642-18378-2_15},
    doi = {10.1007/978-3-642-18378-2_15},
    editor = {Rocha, Ricardo and Launchbury, John},
    isbn = {978-3-642-18377-5},
    keywords = {asynchronous-programming, f-sharp},
    pages = {175--189},
    posted-at = {2015-02-22 22:17:27},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {The F\# Asynchronous Programming Model},
    url = {http://dx.doi.org/10.1007/978-3-642-18378-2_15},
    volume = {6539},
    year = {2011}
}

@book{syme:expert-fsharp,
    author = {Syme, Don and Granicz, Adam and Cisternino, Antonio},
    citeulike-article-id = {13525113},
    keywords = {f-sharp},
    posted-at = {2015-02-22 22:16:29},
    priority = {0},
    publisher = {{APress}},
    title = {Expert {F}\# 3.0},
    year = {2012}
}

@incollection{kobayashi:implicit,
    abstract = {We extend Kobayashi and Sumii's type system for the deadlock-free π-calculus and develop a type reconstruction algorithm. Kobayashi and Sumii's type system helps high-level reasoning about concurrent programs by guaranteeing that communication on certain channels will eventually succeed. It can ensure, for example, that a process implementing a function really behaves like a function. However, because it lacked a type reconstruction algorithm and required rather complicated type annotations, applying it to real concurrent languages was impractical. We have therefore developed a type reconstruction algorithm for an extension of the type system. The key novelties that made it possible are generalization of usages (which specifies how each communication channel is used) and a subusage relation.},
    address = {Berlin, Heidelberg},
    author = {Kobayashi, Naoki and Saito, Shin and Sumii, Eijiro},
    booktitle = {CONCUR 2000 — Concurrency Theory},
    chapter = {35},
    citeulike-article-id = {9647467},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/3-540-44618-4_35},
    citeulike-linkout-1 = {http://www.springerlink.com/content/3r349nu5w56kltqk},
    citeulike-linkout-2 = {http://link.springer.com/chapter/10.1007/3-540-44618-4_35},
    day = {21},
    doi = {10.1007/3-540-44618-4_35},
    editor = {Palamidessi, Catuscia},
    isbn = {978-3-540-67897-7},
    keywords = {deadlock-freedom, pi-calculus},
    month = dec,
    pages = {489--504},
    posted-at = {2014-12-17 15:00:30},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{An Implicitly-Typed Deadlock-Free Process Calculus}},
    url = {http://dx.doi.org/10.1007/3-540-44618-4_35},
    volume = {1877},
    year = {2000}
}

@article{bellin:logic,
    author = {Bellin, G. and Scott, P. J.},
    citeulike-article-id = {13463073},
    citeulike-linkout-0 = {http://dx.doi.org/10.1016/0304-3975(94)00104-9},
    doi = {10.1016/0304-3975(94)00104-9},
    issn = {03043975},
    journal = {Theoretical Computer Science},
    keywords = {linear-logic, pi-calculus},
    month = dec,
    number = {1},
    pages = {11--65},
    posted-at = {2014-12-17 14:59:13},
    priority = {2},
    title = {{On the Pi-calculus and Linear Logic}},
    url = {http://dx.doi.org/10.1016/0304-3975(94)00104-9},
    volume = {135},
    year = {1994}
}

@article{abramsky:interpretations,
    address = {Essex, UK},
    author = {Abramsky, Samson},
    citeulike-article-id = {5399708},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=159531},
    citeulike-linkout-1 = {http://dx.doi.org/10.1016/0304-3975(93)90181-r},
    doi = {10.1016/0304-3975(93)90181-r},
    issn = {03043975},
    journal = {Theoretical Computer Science},
    keywords = {concurrency-theory, linear-logic, pi-caculus},
    month = apr,
    number = {1-2},
    pages = {3--57},
    posted-at = {2014-12-17 14:58:28},
    priority = {0},
    publisher = {Elsevier Science Publishers Ltd.},
    title = {Computational interpretations of linear logic},
    url = {http://dx.doi.org/10.1016/0304-3975(93)90181-r},
    volume = {111},
    year = {1993}
}

@article{kobayashi:linear-picalc,
    abstract = {The economy and flexibility of the pi-calculus make it an attractive object of theoretical study and a clean basis for concurrent language design and implementation. However, such generality has a cost: encoding higher-level features like functional computation in pi-calculus throws away potentially useful information. We show how a linear type system can be used to recover important static information about a process's behavior. In particular, we can guarantee that two processes communicating over a linear channel cannot interfere with other communicating processes. After developing standard results such as soundness of typing, we focus on equivalences, adapting the standard notion of barbed bisimulation to the linear setting and showing how reductions on linear channels induce a  useful  ” partial confluence” of process behaviors. For an extended example of the theory, we prove the validity of a tail-call optimization for higher-order functions represented as processes.},
    address = {New York, NY, USA},
    author = {Kobayashi, Naoki and Pierce, Benjamin C. and Turner, David N.},
    citeulike-article-id = {1806485},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=330249.330251},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/330249.330251},
    doi = {10.1145/330249.330251},
    issn = {0164-0925},
    journal = {ACM Trans. Program. Lang. Syst.},
    keywords = {concurrency-theory, linear-pi-calculus, pi-calculus},
    month = sep,
    number = {5},
    pages = {914--947},
    posted-at = {2014-12-17 14:57:20},
    priority = {2},
    publisher = {ACM},
    title = {{Linearity and the Pi-calculus}},
    url = {http://dx.doi.org/10.1145/330249.330251},
    volume = {21},
    year = {1999}
}

@incollection{honda:async-pi,
    abstract = {This paper presents a formal system based on the notion of objects and asynchronous communication. Built on Milner's work on π-calculus, the communication primitive of the formal system is purely based on asynchronous communication, which makes it unique among various concurrency formalisms. Computationally this results in a consistent reduction of Milner's calculus, while retaining the same expressive power. Seen semantically asynchronous communication induces a surprisingly different framework where bisimulation is strictly more general than its synchronous counterpart. This paper shows basic construction of the formal system along with several illustrative examples.},
    author = {Honda, Kohei and Tokoro, Mario},
    booktitle = {ECOOP'91 European Conference on Object-Oriented Programming},
    citeulike-article-id = {13463065},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/bfb0057019},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/BFb0057019},
    doi = {10.1007/bfb0057019},
    editor = {America, Pierre},
    keywords = {asynchronous-semantics, concurrency, pi-calculus},
    pages = {133--147},
    posted-at = {2014-12-17 14:51:23},
    priority = {5},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {An object calculus for asynchronous communication},
    url = {http://dx.doi.org/10.1007/bfb0057019},
    volume = {512},
    year = {1991}
}

@inproceedings{padovani:deadlock-freedom,
    abstract = {We study two refinements of the linear π-calculus that ensure deadlock freedom (the absence of stable states with pending linear communications) and lock freedom (the eventual completion of pending linear communications). The main feature of both type systems is a new form of channel polymorphism that affects their accuracy in a significant way: they are the first of their kind that can deal with recursive processes connected by cyclic networks.},
    address = {New York, NY, USA},
    author = {Padovani, Luca},
    booktitle = {Proceedings of the Joint Meeting of the Twenty-Third EACSL Annual Conference on Computer Science Logic (CSL) and the Twenty-Ninth Annual ACM/IEEE Symposium on Logic in Computer Science (LICS)},
    citeulike-article-id = {13463060},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2603116},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2603088.2603116},
    doi = {10.1145/2603088.2603116},
    isbn = {978-1-4503-2886-9},
    keywords = {deadlock-freedom, lock-freedom, pi-calculus},
    location = {Vienna, Austria},
    posted-at = {2014-12-17 14:49:55},
    priority = {0},
    publisher = {ACM},
    series = {CSL-LICS '14},
    title = {{Deadlock and Lock Freedom in the Linear pi-calculus}},
    url = {http://dx.doi.org/10.1145/2603088.2603116},
    year = {2014}
}

@article{kobayashi:lock-free,
    author = {Kobayashi, Naoki},
    citeulike-article-id = {9645522},
    citeulike-linkout-0 = {http://dx.doi.org/10.1006/inco.2002.3171},
    day = {15},
    doi = {10.1006/inco.2002.3171},
    issn = {08905401},
    journal = {Information and Computation},
    keywords = {deadlock-freedom, lock-freedom, pi-calculus},
    month = sep,
    number = {2},
    pages = {122--159},
    posted-at = {2014-12-17 14:47:51},
    priority = {0},
    title = {A Type System for {Lock-Free} Processes},
    url = {http://dx.doi.org/10.1006/inco.2002.3171},
    volume = {177},
    year = {2002}
}

@article{kobayashi:deadlock-toplas,
    abstract = {An abstract is not available.},
    address = {New York, NY, USA},
    author = {Kobayashi, Naoki},
    citeulike-article-id = {13463058},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=278524},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/276393.278524},
    doi = {10.1145/276393.278524},
    issn = {0164-0925},
    journal = {ACM Trans. Program. Lang. Syst.},
    keywords = {deadlock-freedom},
    month = mar,
    number = {2},
    pages = {436--482},
    posted-at = {2014-12-17 14:46:47},
    priority = {0},
    publisher = {ACM},
    title = {A Partially Deadlock-free Typed Process Calculus},
    url = {http://dx.doi.org/10.1145/276393.278524},
    volume = {20},
    year = {1998}
}

@techreport{boudol:async-pi,
    author = {Boudol, G{\'{e}}rard},
    citeulike-article-id = {13463056},
    citeulike-linkout-0 = {https://hal.inria.fr/inria-00076939},
    keywords = {asynchronous-semantics, disponible, le, non, pdf, pi-calculus, sur},
    number = {RR-1702},
    pages = {15},
    posted-at = {2014-12-17 14:44:56},
    priority = {0},
    title = {{Asynchrony and the Pi-calculus}},
    type = {Research Report},
    url = {https://hal.inria.fr/inria-00076939},
    year = {1992}
}

@inproceedings{berry:cham,
    abstract = {We introduce a new kind of abstract machine based on the chemical metaphor used in the \&Ggr; language of Ban\^{a}tre \& al. States of a machine are chemical solutions where floating molecules can interact according to reaction rules. Solutions can be stratified by encapsulating subsolutions within membranes that force reactions to occur locally. We illustrate the use of this model by describing the operational semantics of the {TCCS} and {CCS} process calculi. We also show how to extract a higher-order concurrent \&lgr;-calculus out of the basic concepts of the chemical abstract machine.},
    address = {New York, NY, USA},
    author = {Berry, Gerard and Boudol, Gerard},
    booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    citeulike-article-id = {959328},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=96717},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/96709.96717},
    doi = {10.1145/96709.96717},
    isbn = {0-89791-343-4},
    keywords = {asynchronous-semantics, cham},
    location = {San Francisco, California, USA},
    pages = {81--94},
    posted-at = {2014-12-17 14:43:37},
    priority = {2},
    publisher = {ACM},
    series = {POPL '90},
    title = {The Chemical Abstract Machine},
    url = {http://dx.doi.org/10.1145/96709.96717},
    year = {1990}
}

@inproceedings{neelk:spacetime,
    address = {New York, NY, USA},
    author = {Krishnaswami, Neelakantan R.},
    booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming},
    citeulike-article-id = {13460737},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/2500365.2500588},
    citeulike-linkout-1 = {http://doi.acm.org/10.1145/2500365.2500588},
    doi = {10.1145/2500365.2500588},
    keywords = {capabilities, comonads, dataflow, frp, functional, guarded, kripke, logic, logical, programming, reactive, recursion, relations, temporal},
    location = {Boston, Massachusetts, USA},
    pages = {221--232},
    posted-at = {2014-12-14 15:42:55},
    priority = {2},
    publisher = {ACM},
    series = {ICFP '13},
    title = {{Higher-order Functional Reactive Programming Without Spacetime Leaks}},
    url = {http://doi.acm.org/10.1145/2500365.2500588},
    year = {2013}
}

@book{liberty:rx,
    address = {Berkeley, CA, USA},
    author = {Liberty, Jesse and Betts, Paul},
    citeulike-article-id = {13460736},
    edition = {1st},
    keywords = {f, net, reactive-extensions},
    posted-at = {2014-12-14 15:38:31},
    priority = {2},
    publisher = {Apress},
    title = {{Programming Reactive Extensions and LINQ}},
    year = {2011}
}

@incollection{bruni:adaptation,
    abstract = {In this position paper we present a conceptual vision of adaptation, a key feature of autonomic systems. We put some stress on the role of control data and argue how some of the programming paradigms and models used for adaptive systems match with our conceptual framework.},
    author = {Bruni, Roberto and Corradini, Andrea and Gadducci, Fabio and Lluch Lafuente, Alberto and Vandin, Andrea},
    booktitle = {Fundamental Approaches to Software Engineering},
    citeulike-article-id = {13451349},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-28872-2_17},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-28872-2_17},
    doi = {10.1007/978-3-642-28872-2_17},
    editor = {de Lara, Juan and Zisman, Andrea},
    keywords = {adaptive-systems},
    pages = {240--254},
    posted-at = {2014-12-03 16:12:41},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {A Conceptual Framework for Adaptation},
    url = {http://dx.doi.org/10.1007/978-3-642-28872-2_17},
    volume = {7212},
    year = {2012}
}

@inproceedings{coppo:adaptive,
    author = {Coppo, M. and Dezani-Ciancaglini, M. and Venneri, B.},
    booktitle = {Parallel, Distributed and Network-Based Processing (PDP), 2014 22nd Euromicro International Conference on},
    citeulike-article-id = {13451348},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/pdp.2014.18},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=6787348},
    doi = {10.1109/pdp.2014.18},
    institution = {Dipt. di Inf., Univ. di Torino, Turin, Italy},
    issn = {1066-6192},
    keywords = {adaptive-systems, dynamic-monitoring, session-types},
    month = feb,
    pages = {688--696},
    posted-at = {2014-12-03 16:10:26},
    priority = {0},
    publisher = {IEEE},
    title = {{Self-Adaptive Monitors for Multiparty Sessions}},
    url = {http://dx.doi.org/10.1109/pdp.2014.18},
    year = {2014}
}

@incollection{chen:asynchronous,
    abstract = {We propose a formal model of runtime safety enforcement for largescale, cross-language distributed applications with possibly untrusted endpoints. The underlying theory is based on multiparty session types with logical assertions ({MPSA}), an expressive protocol specification language that supports runtime validation through monitoring. Our method starts from global specifications based on {MPSAs} which the participants should obey. Distributed monitors use local specifications, projected from global specifications, to detect whether the interactions are well-behaved, and take appropriate actions, such as suppressing illegal messages. We illustrate the design of our model with examples from real-world distributed applications. We prove monitor transparency, communication conformance, and global session fidelity in the presence of possibly unsafe endpoints.},
    author = {Chen, Tzu-Chun and Bocchi, Laura and Deni\'{e}lou, Pierre-Malo and Honda, Kohei and Yoshida, Nobuko},
    booktitle = {Trustworthy Global Computing},
    citeulike-article-id = {13450613},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-30065-3_2},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-30065-3_2},
    doi = {10.1007/978-3-642-30065-3_2},
    editor = {Bruni, Roberto and Sassone, Vladimiro},
    keywords = {dynamic-monitoring, session-types},
    pages = {25--45},
    posted-at = {2014-12-02 16:24:41},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{Asynchronous Distributed Monitoring for Multiparty Session Enforcement}},
    url = {http://dx.doi.org/10.1007/978-3-642-30065-3_2},
    volume = {7173},
    year = {2012}
}

@article{coppo:progress,
    author = {Coppo, Mario and Dezani-Ciancaglini, Mariangiola and Yoshida, Nobuko and Padovani, Luca},
    citeulike-article-id = {13446887},
    journal = {MSCS (to appear)},
    keywords = {multiparty, session-types},
    posted-at = {2014-11-28 00:22:00},
    priority = {2},
    title = {Global {P}rogress for {D}ynamically {I}nterleaved {M}ultiparty {S}essions},
    year = {2011}
}

@phdthesis{nystrom:thesis,
    author = {Nystr\"{o}m, Jan H.},
    citeulike-article-id = {13446884},
    keywords = {erlang, static-analysis},
    posted-at = {2014-11-28 00:17:51},
    priority = {2},
    school = {Uppsala University},
    title = {{A}nalysing {F}ault {T}olerance for {E}rlang {A}pplications},
    year = {2009}
}

@article{castro:mcerlang,
    author = {Castro, David and Gulias, Victor M. and Benac Earle, Clara and Fredlund, Lars-Ake and Rivas, Samuel},
    citeulike-article-id = {13446883},
    journal = {Electronic Notes in Theoretical Computer Science},
    keywords = {erlang, mcerlang, model-checking},
    pages = {23--40},
    posted-at = {2014-11-28 00:14:55},
    priority = {0},
    publisher = {Elsevier},
    title = {A {C}ase {S}tudy on {V}erifying a {S}upervisor {C}omponent using {M}c{E}rlang},
    volume = {271},
    year = {2011}
}

@inproceedings{neykova:spy,
    author = {Neykova, Rumyana and Yoshida, Nobuko and Hu, Raymond},
    booktitle = {Runtime Verification},
    citeulike-article-id = {13446882},
    keywords = {dynamic-verification, scribble, session-python, session-types},
    organization = {Springer},
    pages = {358--363},
    posted-at = {2014-11-28 00:13:43},
    priority = {0},
    title = {{SPY}: {L}ocal {V}erification of {G}lobal {P}rotocols},
    year = {2013}
}

@article{thomas:automata,
    author = {Thomas, Wolfgang},
    citeulike-article-id = {13446880},
    journal = {Handbook of {T}heoretical {C}omputer {S}cience},
    keywords = {automata, model-checking},
    posted-at = {2014-11-28 00:10:15},
    priority = {2},
    title = {Automata on {I}nfinite {O}bjects},
    volume = {2},
    year = {1990}
}

@inproceedings{fredlund:mcerlang,
    address = {New York, NY, USA},
    author = {Fredlund, Lars-Ake and Svensson, Hans},
    booktitle = {Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming},
    citeulike-article-id = {13446879},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/1291151.1291171},
    citeulike-linkout-1 = {http://doi.acm.org/10.1145/1291151.1291171},
    doi = {10.1145/1291151.1291171},
    keywords = {erlang, model-checking},
    location = {Freiburg, Germany},
    pages = {125--136},
    posted-at = {2014-11-28 00:05:50},
    priority = {0},
    publisher = {ACM},
    series = {ICFP '07},
    title = {{M}c{E}rlang: {A} {M}odel {C}hecker for a {D}istributed {F}unctional {P}rogramming {L}anguage},
    url = {http://doi.acm.org/10.1145/1291151.1291171},
    year = {2007}
}

@article{bellin:pi,
    author = {Bellin, Gianluigi and Scott, Philip J.},
    citeulike-article-id = {13446876},
    journal = {Theoretical Computer Science},
    keywords = {linear-logic, pi-calculus},
    number = {1},
    pages = {11--65},
    posted-at = {2014-11-27 23:57:43},
    priority = {1},
    publisher = {Elsevier},
    title = {On the {P}i-{C}alculus and {L}inear {L}ogic},
    volume = {135},
    year = {1994}
}

@article{abramsky:proofs,
    author = {Abramsky, Samson},
    citeulike-article-id = {13446875},
    journal = {Theoretical Computer Science},
    keywords = {linear-logic, pi-calculus},
    number = {1},
    pages = {5--9},
    posted-at = {2014-11-27 23:55:54},
    priority = {1},
    publisher = {Elsevier},
    title = {Proofs as {P}rocesses},
    volume = {135},
    year = {1994}
}

@book{cesarini:otp,
    author = {Cesarini, F. and Thompson, S. and Vinoski, S.},
    citeulike-article-id = {13446873},
    citeulike-linkout-0 = {http://books.google.co.uk/books?id=koZUngEACAAJ},
    keywords = {erlang, otp},
    posted-at = {2014-11-27 23:52:58},
    priority = {2},
    publisher = {O'Reilly Media, Incorporated},
    title = {Designing for Scalability with {Erlang/OTP}: Implementing Robust, {Fault-Tolerant} Systems},
    url = {http://books.google.co.uk/books?id=koZUngEACAAJ},
    year = {2015}
}

@article{agha:actors,
    author = {Agha, Gul A.},
    citeulike-article-id = {13446870},
    keywords = {actors},
    posted-at = {2014-11-27 23:49:35},
    priority = {1},
    title = {Actors: a {M}odel of {C}oncurrent {C}omputation in {D}istributed {S}ystems},
    year = {1985}
}

@article{capecchi:escape,
    author = {Capecchi, Sara and Giachino, Elena and Yoshida, Nobuko and Others},
    citeulike-article-id = {13445790},
    journal = {Mathematical Structures in Computer Science},
    keywords = {exceptions, multiparty, session-types},
    posted-at = {2014-11-26 12:15:57},
    priority = {0},
    title = {Global {E}scape in {M}ultiparty {S}essions},
    year = {2013}
}

@incollection{hu:session-java,
    abstract = {This paper demonstrates the impact of integrating session types and object-oriented programming, through their implementation in Java. Session types provide high-level abstraction for structuring a series of interactions in a concise syntax, and ensure type-safe communications between distributed peers. We present the first full implementation of a language and runtime for session-based distributed programming featuring asynchronous message passing, delegation, and session subtyping and interleaving, combined with class downloading and failure handling. The compilation-runtime framework of our language effectively maps session abstraction onto underlying transports and guarantees communication safety through static and dynamic session type checking. We have implemented two alternative mechanisms for performing distributed session delegation and prove their correctness. Benchmark results show session abstraction can be realised with low runtime overhead.},
    address = {Berlin, Heidelberg},
    author = {Hu, Raymond and Yoshida, Nobuko and Honda, Kohei},
    booktitle = {ECOOP 2008 – Object-Oriented Programming},
    chapter = {22},
    citeulike-article-id = {3504058},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1428538},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/978-3-540-70592-5_22},
    citeulike-linkout-2 = {http://www.springerlink.com/content/89u86jw627030680},
    citeulike-linkout-3 = {http://link.springer.com/chapter/10.1007/978-3-540-70592-5_22},
    doi = {10.1007/978-3-540-70592-5_22},
    editor = {Vitek, Jan},
    isbn = {978-3-540-70591-8},
    issn = {0302-9743},
    journal = {ECOOP 2008 – Object-Oriented Programming},
    keywords = {session-type-implementations, session-types},
    pages = {516--541},
    posted-at = {2014-11-26 12:10:28},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{Session-Based} Distributed Programming in Java},
    url = {http://dx.doi.org/10.1007/978-3-540-70592-5_22},
    volume = {5142},
    year = {2008}
}

@inproceedings{wadler:propositions-sessions,
    address = {New York, NY, USA},
    author = {Wadler, Philip},
    booktitle = {Proceedings of the 17th ACM SIGPLAN International Conference on Functional Programming},
    citeulike-article-id = {13444944},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/2364527.2364568},
    citeulike-linkout-1 = {http://doi.acm.org/10.1145/2364527.2364568},
    doi = {10.1145/2364527.2364568},
    keywords = {calculus, lambda, linear, linear-logic, logic, pi, session-types},
    location = {Copenhagen, Denmark},
    pages = {273--286},
    posted-at = {2014-11-25 11:56:40},
    priority = {0},
    publisher = {ACM},
    series = {ICFP '12},
    title = {Propositions As {S}essions},
    url = {http://doi.acm.org/10.1145/2364527.2364568},
    year = {2012}
}

@inproceedings{honda:multiparty,
    address = {New York, NY, USA},
    author = {Honda, Kohei and Yoshida, Nobuko and Carbone, Marco},
    booktitle = {Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    citeulike-article-id = {13444940},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/1328438.1328472},
    citeulike-linkout-1 = {http://doi.acm.org/10.1145/1328438.1328472},
    doi = {10.1145/1328438.1328472},
    keywords = {causality, choreography, communications, mobile, multiparty, processes, programming, session, session-types, structured, types},
    location = {San Francisco, California, USA},
    pages = {273--284},
    posted-at = {2014-11-25 11:54:35},
    priority = {0},
    publisher = {ACM},
    series = {POPL '08},
    title = {Multiparty {A}synchronous {S}ession {T}ypes},
    url = {http://doi.acm.org/10.1145/1328438.1328472},
    year = {2008}
}

@article{yoshida:revisited,
    abstract = {Session primitives and types provide a flexible programming style for structured interaction, and are used to statically check the safe and consistent composition of protocols in communication-centric distributed software. Unfortunately authors working on session types have recently realised that some of the previously published systems fail to satisfy the basic theorems of Subject Reduction and Type Safety. This report discusses the issues involved in higher-order session communication, presents a formulation of the recursive types as well as proofs of the Subject Reduction and Type Safety Theorems of the original session typing system by {Honda-Vasconcelos}-Kubo in {ESOP}'98. It also proposes a variant which allows a more liberal higher-order session communication, based on an idea of Gay and Hole.},
    address = {Amsterdam, The Netherlands, The Netherlands},
    author = {Yoshida, Nobuko and Vasconcelos, Vasco T.},
    citeulike-article-id = {1838299},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1274189.1274279},
    citeulike-linkout-1 = {http://dx.doi.org/10.1016/j.entcs.2007.02.056},
    citeulike-linkout-2 = {http://www.sciencedirect.com/science/article/B75H1-4P30GP3-6/1/1f1295da0cc0db94ddd2677ed0c58153},
    doi = {10.1016/j.entcs.2007.02.056},
    issn = {15710661},
    journal = {Electronic Notes in Theoretical Computer Science},
    keywords = {session-types},
    month = jul,
    number = {4},
    pages = {73--93},
    posted-at = {2014-11-24 18:53:59},
    priority = {0},
    publisher = {Elsevier Science Publishers B. V.},
    title = {Language Primitives and Type Discipline for Structured {Communication-Based} Programming Revisited: Two Systems for {Higher-Order} Session Communication},
    url = {http://dx.doi.org/10.1016/j.entcs.2007.02.056},
    volume = {171},
    year = {2007}
}

@incollection{neykova:actors,
    abstract = {Actor coordination armoured with a suitable protocol description language has been a pressing problem in the actors community. We study the applicability of multiparty session type ({MPST}) protocols for verification of actor programs. We incorporate sessions to actors by introducing minimum additions to the model such as the notion of actor roles and protocol mailboxes. The framework uses Scribble, which is a protocol description language based on multiparty session types. Our programming model supports actor-like syntax and runtime verification mechanism guaranteeing communication safety of the participating entities. An actor can implement multiple roles in a similar way as an object can implement multiple interfaces. Multiple roles allow for cooperative inter-concurrency in a single actor. We demonstrate our framework by designing and implementing a session actor library in Python and its runtime verification mechanism. Benchmark results demonstrate that the runtime checks induce negligible overhead.},
    author = {Neykova, Rumyana and Yoshida, Nobuko},
    booktitle = {Coordination Models and Languages},
    citeulike-article-id = {13435018},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-662-43376-8_9},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-662-43376-8_9},
    doi = {10.1007/978-3-662-43376-8_9},
    editor = {K\"{u}hn, Eva and Pugliese, Rosario},
    keywords = {dynamic-monitoring, session-actors, session-types},
    pages = {131--146},
    posted-at = {2014-11-20 15:14:42},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{M}ultiparty {S}ession {A}ctors},
    url = {http://dx.doi.org/10.1007/978-3-662-43376-8_9},
    year = {2014}
}

@incollection{ng:session-c,
    abstract = {This paper presents a new efficient programming toolchain for message-passing parallel algorithms which can fully ensure, for any typable programs and for any execution path, deadlock-freedom, communication safety and global progress through a static checking. The methodology is embodied as a multiparty session-based programming environment for C and its runtime libraries, which we call Session C. Programming starts from specifying a global protocol for a target parallel algorithm, using a protocol description language. From this global protocol, the projection algorithm generates endpoint protocols, based on which each endpoint C program is designed and implemented with a small number of concise session primitives. The endpoint protocol can further be refined to a more optimised protocol through subtyping for asynchronous communication, preserving original safety guarantees. The underlying theory can ensure that the complexity of the toolchain stays in polynomial time against the size of programs. We apply this framework to representative parallel algorithms with complex communication topologies. The benchmark results show that Session C performs competitively against {MPI}.},
    author = {Ng, Nicholas and Yoshida, Nobuko and Honda, Kohei},
    booktitle = {Objects, Models, Components, Patterns},
    citeulike-article-id = {13435014},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-30561-0_15},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-30561-0_15},
    doi = {10.1007/978-3-642-30561-0_15},
    editor = {Furia, CarloA and Nanz, Sebastian},
    keywords = {scribble, session-c, session-types},
    pages = {202--218},
    posted-at = {2014-11-20 15:13:57},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Multiparty {S}ession {C}: {S}afe {P}arallel {P}rogramming with {M}essage {O}ptimisation},
    url = {http://dx.doi.org/10.1007/978-3-642-30561-0_15},
    volume = {7304},
    year = {2012}
}

@incollection{denielou:automata,
    abstract = {Communicating finite state machines ({CFSMs}) represent processes which communicate by asynchronous exchanges of messages via {FIFO} channels. Their major impact has been in characterising essential properties of communications such as freedom from deadlock and communication error, and buffer boundedness. {CFSMs} are known to be computationally hard: most of these properties are undecidable even in restricted cases. At the same time, multiparty session types are a recent typed framework whose main feature is its ability to efficiently enforce these properties for mobile processes and programming languages. This paper ties the links between the two frameworks to achieve a two-fold goal. On one hand, we present a generalised variant of multiparty session types that have a direct semantical correspondence to {CFSMs}. Our calculus can treat expressive forking, merging and joining protocols that are absent from existing session frameworks, and our typing system can ensure properties such as safety, boundedness and liveness on distributed processes by a polynomial time type checking. On the other hand, multiparty session types allow us to identify a new class of {CFSMs} that automatically enjoy the aforementioned properties , generalising Gouda et al's work [12] (for two machines) to an arbitrary number of machines.},
    author = {Deni\'{e}lou, Pierre-Malo and Yoshida, Nobuko},
    booktitle = {Programming Languages and Systems},
    citeulike-article-id = {13435011},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-28869-2_10},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-28869-2_10},
    doi = {10.1007/978-3-642-28869-2_10},
    editor = {Seidl, Helmut},
    keywords = {automata, dynamic-monitoring, session-types},
    pages = {194--213},
    posted-at = {2014-11-20 15:13:09},
    priority = {5},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Multiparty Session Types Meet Communicating Automata},
    url = {http://dx.doi.org/10.1007/978-3-642-28869-2_10},
    volume = {7211},
    year = {2012}
}

@inproceedings{wieselthier:bip,
    abstract = {The wireless networking environment presents formidable challenges to the study of broadcasting and multicasting problems. After addressing the characteristics of wireless networks that distinguish them from wired networks, we introduce and evaluate algorithms for tree construction in infrastructureless, all-wireless applications. The performance metric used to evaluate broadcast and multicast trees is energy-efficiency. We develop the broadcast incremental power algorithm, and adapt it to multicast operation as well. This algorithm exploits the broadcast nature of the wireless communication environment, and addresses the need for energy-efficient operation. We demonstrate that our algorithm provides better performance than algorithms that have been developed for the link-based, wired environment},
    author = {Wieselthier, J. E. and Nguyen, Gam D. and Ephremides, Anthony},
    booktitle = {INFOCOM 2000. Nineteenth Annual Joint Conference of the IEEE Computer and Communications Societies. Proceedings. IEEE},
    citeulike-article-id = {507256},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/infcom.2000.832232},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=832232},
    doi = {10.1109/infcom.2000.832232},
    institution = {Div. of Inf. Technol., Naval Res. Lab., Washington, DC, USA},
    isbn = {0-7803-5880-5},
    issn = {0743-166X},
    journal = {INFOCOM 2000. Nineteenth Annual Joint Conference of the IEEE Computer and Communications Societies. Proceedings. IEEE},
    keywords = {wireless-networks},
    pages = {585--594 vol.2},
    posted-at = {2014-11-05 16:44:01},
    priority = {0},
    publisher = {IEEE},
    title = {On the construction of energy-efficient broadcast and multicast trees in wireless networks},
    url = {http://dx.doi.org/10.1109/infcom.2000.832232},
    volume = {2},
    year = {2000}
}

@unpublished{lindley:semantics,
    author = {Lindley, S. and Morris, J. Garrett},
    citeulike-article-id = {13406109},
    howpublished = {Draft},
    keywords = {session-types, sessions-as-propositions},
    posted-at = {2014-10-23 13:22:43},
    priority = {5},
    title = {A {S}emantics for {P}ropositions as {S}essions}
}

@inproceedings{lindley:sessions-propositions,
    author = {Lindley, Sam and Morris, J. Garrett},
    booktitle = {{Proceedings of the 7th Workshop on Programming Language Approaches to Concurrency and Communication-cEntric Software}},
    citeulike-article-id = {13406103},
    citeulike-linkout-0 = {http://dx.doi.org/10.4204/EPTCS.155.2},
    doi = {10.4204/EPTCS.155.2},
    editor = {Donaldson, Alastair F. and Vasconcelos, Vasco T.},
    location = {{G}renoble, {F}rance},
    pages = {9--16},
    posted-at = {2014-10-23 13:09:57},
    priority = {2},
    publisher = {Open Publishing Association},
    series = {Electronic Proceedings in Theoretical Computer Science},
    title = {{S}essions as {P}ropositions},
    url = {http://dx.doi.org/10.4204/EPTCS.155.2},
    volume = {155},
    year = {2014}
}

@article{gay:subtyping,
    abstract = {Extending the pi calculus with the session types proposed by Honda et al. allows high-level specifications of structured patterns of communication, such as client-server protocols, to be expressed as types and verified by static typechecking. We define a notion of subtyping for session types, which allows protocol specifications to be extended in order to describe richer behaviour; for example, an implemented server can be refined without invalidating type-correctness of an overall system. We formalize the syntax, operational semantics and typing rules of an extended pi calculus, prove that typability guarantees absence of run-time communication errors, and show that the typing rules can be transformed into a practical typechecking algorithm.},
    author = {Gay, Simon and Hole, Malcolm},
    citeulike-article-id = {1395035},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1104643.1104646},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/s00236-005-0177-z},
    citeulike-linkout-2 = {http://www.springerlink.com/content/bg975k9j23235021},
    day = {22},
    doi = {10.1007/s00236-005-0177-z},
    issn = {0001-5903},
    journal = {Acta Informatica},
    keywords = {picalculus, session-types, subtyping},
    month = nov,
    number = {2},
    pages = {191--225},
    posted-at = {2014-10-21 17:35:01},
    priority = {0},
    publisher = {Springer Berlin / Heidelberg},
    title = {Subtyping for session types in the pi calculus},
    url = {http://dx.doi.org/10.1007/s00236-005-0177-z},
    volume = {42},
    year = {2005}
}

@inproceedings{denielou:multirole,
    address = {New York, NY, USA},
    author = {Deni{\'{e}}lou, Pierre-Malo and Yoshida, Nobuko},
    booktitle = {Proceedings of the 38th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    citeulike-article-id = {13402931},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/1926385.1926435},
    citeulike-linkout-1 = {http://doi.acm.org/10.1145/1926385.1926435},
    doi = {10.1145/1926385.1926435},
    keywords = {auction, communications, dynamic, join-leave, mobile, multiparty, multirole, peer-to-peer, processes, protocols, roles, session, session-types, types},
    location = {Austin, Texas, USA},
    pages = {435--446},
    posted-at = {2014-10-21 12:27:12},
    priority = {2},
    publisher = {ACM},
    series = {POPL '11},
    title = {Dynamic Multirole Session Types},
    url = {http://doi.acm.org/10.1145/1926385.1926435},
    year = {2011}
}

@incollection{mostrous:session-erlang,
    abstract = {As software tends to be increasingly concurrent, the paradigm ofmessage passing is becoming more prominent in computing. The language Erlang offers an intuitive and industry-testedimplementation of process-oriented programming, combining pattern-matching with message mailboxes, resulting in concise, elegant programs. However, it lacks a successful static verification mechanism that ensures safety and determinism of communications with respect to well-defined specifications. We present a session typing system for a featherweight Erlang calculus that encompasses the main communication abilities of the language. In this system, structured types are used to govern the interaction of Erlang processes, ensuring that their behaviour is safe with respect to a defined protocol. The expected properties of subject reduction and type safety are established.},
    author = {Mostrous, Dimitris and Vasconcelos, Vasco T.},
    booktitle = {Coordination Models and Languages},
    citeulike-article-id = {13385667},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-21464-6_7},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-21464-6_7},
    doi = {10.1007/978-3-642-21464-6_7},
    editor = {De Meuter, Wolfgang and Roman, Gruia-Catalin},
    keywords = {concurrency-theory, erlang, session-types},
    pages = {95--109},
    posted-at = {2014-10-08 11:04:47},
    priority = {5},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Session Typing for a Featherweight Erlang},
    url = {http://dx.doi.org/10.1007/978-3-642-21464-6_7},
    volume = {6721},
    year = {2011}
}

@article{giunti:session-type-checking,
    author = {Giunti, Marco},
    citeulike-article-id = {13385656},
    citeulike-linkout-0 = {http://dx.doi.org/10.1016/j.jlap.2013.05.003},
    doi = {10.1016/j.jlap.2013.05.003},
    issn = {15678326},
    journal = {The Journal of Logic and Algebraic Programming},
    keywords = {implementation, session-types},
    month = nov,
    number = {8},
    pages = {263--281},
    posted-at = {2014-10-08 10:47:03},
    priority = {3},
    title = {Algorithmic type checking for a pi-calculus with name matching and session types},
    url = {http://dx.doi.org/10.1016/j.jlap.2013.05.003},
    volume = {82},
    year = {2013}
}

@article{vasco:fundamentals,
    abstract = {We present a reconstruction of session types in a linear pi calculus where types are qualified as linear or unrestricted. Linearly qualified communication channels are guaranteed to occur in exactly one thread, possibly multiple times; unrestricted (or shared) channels may appear in an unbounded number of threads. In our language each channel is characterized by two distinct variables, one used for reading, the other for writing; scope restriction binds together two variables, thus establishing the correspondence between the two ends of a same channel. This mechanism allows a precise control of resources via a conventional linear type system. Furthermore, the uniform treatment of linear and shared channels leads to a surprisingly simply theory which, in addition, extends typability when compared to traditional systems for session types. We build the language gradually, starting from simple input/output, then adding recursive types, replication and finally choice. We also present an algorithmic type checking system.},
    author = {Vasconcelos, Vasco T.},
    citeulike-article-id = {10703343},
    citeulike-linkout-0 = {http://dx.doi.org/10.1016/j.ic.2012.05.002},
    doi = {10.1016/j.ic.2012.05.002},
    issn = {08905401},
    journal = {Information and Computation},
    keywords = {session-types},
    month = aug,
    pages = {52--70},
    posted-at = {2014-10-04 15:54:50},
    priority = {4},
    title = {Fundamentals of session types},
    url = {http://dx.doi.org/10.1016/j.ic.2012.05.002},
    volume = {217},
    year = {2012}
}

@article{asperti:affine,
    abstract = {This article is a structured introduction to Intuitionistic Light Affine Logic ({ILAL}). {ILAL} has a polynomially costing normalization, and it is expressive enough to encode, and simulate, all {PolyTime} Turing machines. The bound on the normalization cost is proved by introducing the proof-nets for {ILAL}. The bound follows from a suitable normalization strategy that exploits structural properties of the proof-nets. This allows us to have a good understanding of the meaning of the {\S} modality, which is a peculiarity of light logics. The expressive power of {ILAL} is demonstrated in full detail. Such a proof gives a hint of the nontrivial task of programming with resource limitations, using {ILAL} derivations as programs.},
    address = {New York, NY, USA},
    author = {Asperti, Andrea and Roversi, Luca},
    citeulike-article-id = {13382356},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=504081},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/504077.504081},
    doi = {10.1145/504077.504081},
    issn = {1529-3785},
    journal = {ACM Trans. Comput. Logic},
    keywords = {affine-logic},
    month = jan,
    number = {1},
    pages = {137--175},
    posted-at = {2014-10-04 15:49:20},
    priority = {2},
    publisher = {ACM},
    title = {Intuitionistic Light Affine Logic},
    url = {http://dx.doi.org/10.1145/504077.504081},
    volume = {3},
    year = {2002}
}

@incollection{hu:interruptible,
    abstract = {The rigorous and comprehensive verification of communication-based software is an important engineering challenge in distributed systems. Drawn from our industrial collaborations [33,28] on Scribble, a choreography description language based on multiparty session types, this paper proposes a dynamic verification framework for structured interruptible conversation programming. We first present our extension of Scribble to support the specification of asynchronously interruptible conversations. We then implement a concise {API} for conversation programming with interrupts in Python that enables session types properties to be dynamically verified for distributed processes. Our framework ensures the global safety of a system in the presence of asynchronous interrupts through independent runtime monitoring of each endpoint, checking the conformance of the local execution trace to the specified protocol. The usability of our framework for describing and verifying choreographic communications has been tested by integration into the large scientific cyberinfrastructure developed by the Ocean Observatories Initiative. Asynchronous interrupts have proven expressive enough to represent and verify their main classes of communication patterns, including asynchronous streaming and various timeout-based protocols, without requiring additional synchronisation mechanisms. Benchmarks show conversation programming and monitoring can be realised with little overhead.},
    author = {Hu, Raymond and Neykova, Rumyana and Yoshida, Nobuko and Demangeon, Romain and Honda, Kohei},
    booktitle = {Runtime Verification},
    citeulike-article-id = {13382351},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-40787-1_8},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-40787-1_8},
    doi = {10.1007/978-3-642-40787-1_8},
    editor = {Legay, Axel and Bensalem, Saddek},
    keywords = {exceptions, scribble, session-types},
    pages = {130--148},
    posted-at = {2014-10-04 15:34:10},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Practical Interruptible Conversations},
    url = {http://dx.doi.org/10.1007/978-3-642-40787-1_8},
    volume = {8174},
    year = {2013}
}

@incollection{mostrous:affine,
    abstract = {Session types describe the structure of protocols from the point of view of each participating channel. In particular, the types describe the type of communicated values, and also the dynamic alternation of input and output actions on the same channel, by which a protocol can be statically verified. Crucial to any term language with session types is the notion of linearity, which guarantees that channels exhibit exactly the behaviour prescribed by their type. We relax the condition of linearity to that of affinity, by which channels exhibit at most the behaviour prescribed by their types. This more liberal setting allows us to incorporate an elegant error handling mechanism which simplifies and improves related works on exceptions. Moreover, our treatment does not affect the progress properties of the language: sessions never get stuck.},
    author = {Mostrous, Dimitris and Vasconcelos, Vasco T.},
    booktitle = {Coordination Models and Languages},
    citeulike-article-id = {13382350},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-662-43376-8_8},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-662-43376-8_8},
    doi = {10.1007/978-3-662-43376-8_8},
    editor = {K\"{u}hn, Eva and Pugliese, Rosario},
    keywords = {affine-sessions, exceptions, session-types},
    pages = {115--130},
    posted-at = {2014-10-04 15:32:21},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Affine Sessions},
    url = {http://dx.doi.org/10.1007/978-3-662-43376-8_8},
    year = {2014}
}

@article{carbone:exception-choreographies,
    abstract = {Choreography has recently emerged as a pragmatic and concise way of describing communication-based systems such as web services and financial protocols. Recent studies have investigated the transition from the design stage of a system to its implementation providing an automatic way of mapping a choreograhy into executable code. In this work, we focus on an extension of choreography with a communication-based (interactional) exception mechanism by giving its formal semantics. In particular, we discuss through some examples how interactional exceptions at choreography level can be implemented into end-point code.},
    author = {Carbone, Marco},
    citeulike-article-id = {5068476},
    citeulike-linkout-0 = {http://dx.doi.org/10.1016/j.entcs.2009.06.003},
    day = {03},
    doi = {10.1016/j.entcs.2009.06.003},
    issn = {15710661},
    journal = {Electronic Notes in Theoretical Computer Science},
    keywords = {exceptions, session-types},
    month = jul,
    pages = {35--55},
    posted-at = {2014-10-04 15:29:52},
    priority = {5},
    title = {Session-based Choreography with Exceptions},
    url = {http://dx.doi.org/10.1016/j.entcs.2009.06.003},
    volume = {241},
    year = {2009}
}

@article{cappechi:escape,
    author = {Capecchi, Sara and Giachino, Elena and Yoshida, Nobuko and Others},
    citeulike-article-id = {13382348},
    journal = {Mathematical Structures in Computer Science},
    keywords = {exceptions, session-types},
    posted-at = {2014-10-04 15:28:41},
    priority = {0},
    title = {Global escape in multiparty sessions},
    year = {2013}
}

@incollection{bocchi:monitoring,
    abstract = {In large-scale distributed infrastructures, applications are realised through communications among distributed components. The need for methods for assuring safe interactions in such environments is recognized, however the existing frameworks, relying on centralised verification or restricted specification methods, have limited applicability. This paper proposes a new theory of monitored π-calculus with dynamic usage of multiparty session types ({MPST}), offering a rigorous foundation for safety assurance of distributed components which asynchronously communicate through multiparty sessions. Our theory establishes a framework for semantically precise decentralised run-time enforcement and provides reasoning principles over monitored distributed applications, which complement existing static analysis techniques. We introduce asynchrony through the means of explicit routers and global queues, and propose novel equivalences between networks, that capture the notion of interface equivalence, i.e. equating networks offering the same services to a user. We illustrate our static-dynamic analysis system with an {ATM} protocol as a running example and justify our theory with results: satisfaction equivalence, local/global safety and transparency, and session fidelity.},
    author = {Bocchi, Laura and Chen, Tzu-Chun and Demangeon, Romain and Honda, Kohei and Yoshida, Nobuko},
    booktitle = {Formal Techniques for Distributed Systems},
    citeulike-article-id = {13382346},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-38592-6_5},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-38592-6_5},
    doi = {10.1007/978-3-642-38592-6_5},
    editor = {Beyer, Dirk and Boreale, Michele},
    keywords = {monitoring, scribble, session-types},
    pages = {50--65},
    posted-at = {2014-10-04 15:26:30},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Monitoring Networks through Multiparty Session Types},
    url = {http://dx.doi.org/10.1007/978-3-642-38592-6_5},
    volume = {7892},
    year = {2013}
}

@inproceedings{ng:pabble,
    author = {Ng, Nicholas and Yoshida, Nobuko},
    booktitle = {Parallel, Distributed and Network-Based Processing (PDP), 2014 22nd Euromicro International Conference on},
    citeulike-article-id = {13382345},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/pdp.2014.20},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=6787350},
    doi = {10.1109/pdp.2014.20},
    institution = {Imperial Coll. London, London, UK},
    issn = {1066-6192},
    keywords = {hpc, pabble, scribble, session-types},
    month = feb,
    pages = {707--714},
    posted-at = {2014-10-04 15:24:33},
    priority = {2},
    publisher = {IEEE},
    title = {Pabble: Parameterised Scribble for Parallel Programming},
    url = {http://dx.doi.org/10.1109/pdp.2014.20},
    year = {2014}
}

@techreport{syme:type-providers,
    author = {Syme, Don and Battocchi, Keith and Takeda, Kenji and Malayeri, Donna and Fisher, Jomo and Hu, Jack and Liu, Tao and McNamara, Brian and Quirk, Daniel and Taveggia, Matteo and Chae, Wonseok and Matsveyeu, Uladzimir and Petricek, Tomas},
    citeulike-article-id = {13339284},
    institution = {Technical Report MSR-TR-2012-101, Microsoft Research},
    keywords = {f, type-providers},
    posted-at = {2014-08-28 09:18:04},
    priority = {2},
    title = {Strongly-typed language support for internet-scale information sources},
    year = {2012}
}

@inproceedings{flapjax,
    address = {New York, NY, USA},
    author = {Meyerovich, Leo A. and Guha, Arjun and Baskin, Jacob and Cooper, Gregory H. and Greenberg, Michael and Bromfield, Aleks and Krishnamurthi, Shriram},
    booktitle = {Proceedings of the 24th ACM SIGPLAN Conference on Object Oriented Programming Systems Languages and Applications},
    citeulike-article-id = {13318248},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/1640089.1640091},
    doi = {10.1145/1640089.1640091},
    keywords = {dataflow, functional, functional-reactive-programming, javascript, programming, reactive, web, web-programming},
    location = {Orlando, Florida, USA},
    pages = {1--20},
    posted-at = {2014-08-07 15:45:38},
    priority = {2},
    publisher = {ACM},
    series = {OOPSLA '09},
    title = {{F}lapjax: {A} {P}rogramming {L}anguage for {A}jax {A}pplications},
    url = {http://dx.doi.org/10.1145/1640089.1640091},
    year = {2009}
}

@book{reppy:cml,
    author = {Reppy, John H.},
    citeulike-article-id = {13318242},
    keywords = {concurrency, functional-programming},
    posted-at = {2014-08-07 15:42:18},
    priority = {2},
    publisher = {Cambridge University Press},
    title = {{C}oncurrent {P}rogramming in {ML}},
    year = {2007}
}

@incollection{cooper:frtime,
    abstract = {This paper describes {FrTime}, an extension of Scheme designed for writing interactive applications. Inspired by functional reactive programming, the language embeds dynamic dataflow within a call-by-value functional language. The essence of the embedding is to make program expressions evaluate to nodes in a dataflow graph. This strategy eases importation of legacy code and permits incremental program construction. We have integrated {FrTime} with the {DrScheme} programming environment and have used it to develop several novel applications. We describe {FrTime}'s design and implementation in detail and present a formal semantics of its evaluation model.},
    author = {Cooper, Gregory H. and Krishnamurthi, Shriram},
    booktitle = {Programming Languages and Systems},
    citeulike-article-id = {2902928},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/11693024_20},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/11693024_20},
    doi = {10.1007/11693024_20},
    editor = {Sestoft, Peter},
    journal = {Programming Languages and Systems},
    keywords = {dataflow},
    pages = {294--308},
    posted-at = {2014-08-07 15:36:21},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{E}mbedding {D}ynamic {D}ataflow in a {C}all-by-{V}alue {L}anguage},
    url = {http://dx.doi.org/10.1007/11693024_20},
    volume = {3924},
    year = {2006}
}

@electronic{bostock:constancy,
    author = {Bostock, Mike},
    citeulike-article-id = {13318235},
    howpublished = {\url{http://bost.ocks.org/mike/constancy/}},
    keywords = {d3, infovis, web-programming},
    posted-at = {2014-08-07 15:35:14},
    priority = {0},
    title = {{O}bject {C}onstancy},
    year = {2012}
}

@inproceedings{mandel:reactiveml,
    abstract = {We present {ReactiveML}, a programming language dedicated to the implementation of complex reactive systems as found in graphical user interfaces, video games or simulation problems. The language is based on the reactive model introduced by Boussinot. This model combines the so-called synchronous model found in Esterel which provides instantaneous communication and parallel composition with classical features found in asynchronous models like dynamic creation of {processes.The} language comes as a conservative extension of an existing call-by-value {ML} language and it provides additional constructs for describing the temporal part of a system. The language receives a behavioral semantics \'{a} la Esterel and a transition semantics describing precisely the interaction between {ML} values and reactive constructs. It is statically typed through a Milner type inference system and programs are compiled into regular {ML} programs. The language has been used for programming several complex simulation problems (e.g., routing protocols in mobile ad-hoc networks).},
    address = {New York, NY, USA},
    author = {Mandel, Louis and Pouzet, Marc},
    booktitle = {Proceedings of the 7th ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming},
    citeulike-article-id = {13318228},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1069782},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1069774.1069782},
    doi = {10.1145/1069774.1069782},
    isbn = {1-59593-090-6},
    keywords = {dataflow, functional-programming, synchronous-dataflow},
    location = {Lisbon, Portugal},
    pages = {82--93},
    posted-at = {2014-08-07 15:30:20},
    priority = {0},
    publisher = {ACM},
    series = {PPDP '05},
    title = {{R}eactive{ML}: {A} {R}eactive {E}xtension to {ML}},
    url = {http://dx.doi.org/10.1145/1069774.1069782},
    year = {2005}
}

@inbook{plasmeijer:idata,
    abstract = {In this paper we present the {iData} Toolkit. It allows programmers to create interactive, dynamic web applications with state on a high level of abstraction. The key element of this toolkit is the {iData} element. An {iData} element can be regarded as a self-contained object that stores values of a specified type. Generic programming techniques enable the automatic generation of {HTML}-forms from these types. These forms can be plugged into the web application. The {iData} elements can be interconnected. Complicated form dependencies can be defined in a pure functional, type safe, declarative programming style. This liberates the programmer from lots of low-level {HTML} programming and form handling. We illustrate the descriptive power of the toolkit by means of a small, yet complicated example: a project administration. The {iData} Toolkit is an excellent demonstration of the expressive power of modern generic (poly-typical) programming techniques.},
    author = {Plasmeijer, Rinus and Achten, Peter},
    booktitle = {Functional and Logic Programming},
    citeulike-article-id = {13318226},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/11737414_17},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/11737414_17},
    doi = {10.1007/11737414_17},
    editor = {Hagiya, Masami and Wadler, Philip},
    keywords = {functional-programming, web-abstractions, web-programming},
    pages = {242--258},
    posted-at = {2014-08-07 15:28:55},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {FLOPS '06},
    title = {i{D}ata for the {W}orld {W}ide {W}eb -- {Programming Interconnected Web Forms}},
    url = {http://dx.doi.org/10.1007/11737414_17},
    volume = {3945},
    year = {2006}
}

@electronic{ocaml-react,
    author = {B\"{u}nzli, Daniel},
    citeulike-article-id = {13318215},
    howpublished = {\url{http://erratique.ch/software/react}},
    keywords = {dataflow, functional-programming},
    posted-at = {2014-08-07 15:19:40},
    priority = {0},
    title = {{R}eact / {E}rratique},
    year = {2010}
}

@electronic{react,
    citeulike-article-id = {13318212},
    howpublished = {\url{http://facebook.github.io/react/}},
    keywords = {reactive, web-programming},
    posted-at = {2014-08-07 15:17:20},
    priority = {0},
    title = {{R}eact | {A} {J}ava{S}cript {L}ibrary for {B}uilding {U}ser {I}nterfaces},
    year = {2014}
}

@inproceedings{plasmeijer:itasks,
    address = {New York, NY, USA},
    author = {Plasmeijer, Rinus and Achten, Peter and Koopman, Pieter},
    booktitle = {Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming},
    citeulike-article-id = {13318208},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/1291151.1291174},
    citeulike-linkout-1 = {http://doi.acm.org/10.1145/1291151.1291174},
    doi = {10.1145/1291151.1291174},
    keywords = {clean, functional-programming, idata, itask, web, web-abstractions},
    location = {Freiburg, Germany},
    pages = {141--152},
    posted-at = {2014-08-07 15:08:39},
    priority = {0},
    publisher = {ACM},
    series = {ICFP '07},
    title = {i{T}asks: {E}xecutable {S}pecifications of {I}nteractive {W}ork {F}low {S}ystems for the {W}eb},
    url = {http://doi.acm.org/10.1145/1291151.1291174},
    year = {2007}
}

@incollection{syme:quotations,
    author = {Syme, Don and Granicz, Adam and Cisternino, Antonio},
    booktitle = {Expert F\# 3.0},
    citeulike-article-id = {13318195},
    keywords = {f, functional-programming, quotations},
    pages = {477--501},
    posted-at = {2014-08-07 14:40:03},
    priority = {0},
    publisher = {Springer},
    title = {{Language-Oriented} Programming: Advanced Techniques},
    year = {2012}
}

@article{hughes:arrows,
    abstract = {Monads have become very popular for structuring functional programs since Wadler introduced their use in 1990. In particular, libraries of combinators are often based on a monadic type. Such libraries share (in part) a common interface, from which numerous benefits flow, such as the possibility to write generic code which works together with any library. But, several interesting and useful libraries are fundamentally incompatible with the monadic interface. In this paper I propose a generalisation of monads, which I call arrows, with significantly wider applicability. The paper shows how many of the techniques of monadic programming generalise to the new setting, and gives examples to show that the greater generality is useful. In particular, three non-monadic libraries for efficient parsing, building graphical user interfaces, and programming active web pages fit naturally into the new framework.},
    author = {Hughes, John},
    citeulike-article-id = {99883},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=347246},
    citeulike-linkout-1 = {http://dx.doi.org/10.1016/s0167-6423(99)00023-4},
    citeulike-linkout-2 = {http://www.sciencedirect.com/science/article/B6V17-43FX0HF-4/2/bed32a698e8d06bea3c700ff8b8e84f1},
    doi = {10.1016/s0167-6423(99)00023-4},
    issn = {01676423},
    journal = {Science of Computer Programming},
    keywords = {arrows, functional-abstractions, functional-programming},
    month = may,
    number = {1-3},
    pages = {67--111},
    posted-at = {2014-08-07 14:20:07},
    priority = {2},
    publisher = {Elsevier North-Holland, Inc.},
    title = {Generalising monads to arrows},
    url = {http://dx.doi.org/10.1016/s0167-6423(99)00023-4},
    volume = {37},
    year = {2000}
}

@inproceedings{wan:rt-frp,
    abstract = {Functional reactive programming ({FRP}) is a declarative programming paradigm where the basic notions are continuous, time-varying behaviors and discrete, event-based reactivity. {FRP} has been used successfully in many reactive programming domains such as animation, robotics, and graphical user interfaces. The success of {FRP} in these domains encourages us to consider its use in real-time applications, where it is crucial that the cost of running a program be bounded and known before run-time. But previous work on the semantics and implementation of {FRP} was not explicitly concerned about the issues of cost. In fact, the resource consumption of {FRP} programs in the current implementation is often hard to predict. As a first step towards addressing these concerns, this paper presents real-time {FRP} ({RT}-{FRP}), a statically-typed language where the time and space cost of each execution step for a given program is statically bounded. To take advantage of existing work on languages with bounded resources, we split {RT}-{FRP} into two parts: a reactive part that captures the essential ingredients of {FRP} programs, and a base language part that can be instantiated to any generic programming language that has been shown to be terminating and resource-bounded. This allows us to focus on the issues specific to {RT}-{FRP}, namely, two forms of recursion. After presenting the operational explanation of what can go wrong due to the presence of recursion, we show how the typed version of the language is terminating and resource-bounded. Most of our {FRP} programs are expressible directly in {RT}. The rest are expressible via a simple mechanism that integrates {RT}-{FRP} with the base language.},
    address = {New York, NY, USA},
    author = {Wan, Zhanyong and Taha, Walid and Hudak, Paul},
    booktitle = {Proceedings of the Sixth ACM SIGPLAN International Conference on Functional Programming},
    citeulike-article-id = {4977},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=507654},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/507635.507654},
    doi = {10.1145/507635.507654},
    isbn = {1-58113-415-0},
    keywords = {functional-reactive-programming, real-time},
    location = {Florence, Italy},
    month = oct,
    number = {10},
    pages = {146--156},
    posted-at = {2014-08-07 14:09:46},
    priority = {2},
    publisher = {ACM},
    series = {ICFP '01},
    title = {Real-time {FRP}},
    url = {http://dx.doi.org/10.1145/507635.507654},
    volume = {36},
    year = {2001}
}

@incollection{wan:e-frp,
    abstract = {Functional Reactive Programming ({FRP}) is a high-level declarative language for programming reactive systems. Previous work on {FRP} has demonstrated its utility in a wide range of application domains, including animation, graphical user interfaces, and robotics. {FRP} has an elegant continuous-time denotational semantics. However, it guarantees no bounds on execution time or space, thus making it unsuitable for many embedded real-time applications. To alleviate this problem, we recently developed {Real-Time} {FRP} ({RT}-{FRP}), whose operational semantics permits us to formally guarantee bounds on both execution time and space.
                            In this paper we present a formally verifiable compilation strategy from a new language based on {RT}-{FRP} into imperative code. The new language, called {Event-Driven} {FRP} ({E-FRP}), is more tuned to the paradigm of having multiple external events. While it is smaller than {RT}-{FRP}, it features a key construct that allows us to compile the language into efficient code. We have used this language and its compiler to generate code for a small robot controller that runs on a {PIC16C66} micro-controller. Because the formal specification of compilation was crafted more for clarity and for technical convenience, we describe an implementation that produces more efficient code.},
    author = {Wan, Zhanyong and Taha, Walid and Hudak, Paul},
    booktitle = {Practical Aspects of Declarative Languages},
    citeulike-article-id = {13318176},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/3-540-45587-6_11},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/3-540-45587-6_11},
    doi = {10.1007/3-540-45587-6_11},
    editor = {Krishnamurthi, Shriram and Ramakrishnan, C. R.},
    keywords = {event, functional-reactive-programming, real-time},
    pages = {155--172},
    posted-at = {2014-08-07 14:08:01},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {{Event-Driven} {FRP}},
    url = {http://dx.doi.org/10.1007/3-540-45587-6_11},
    volume = {2257},
    year = {2002}
}

@article{halbwachs:lustre,
    author = {Halbwachs, N. and Caspi, P. and Raymond, P. and Pilaud, D.},
    citeulike-article-id = {13317733},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/5.97300},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=97300},
    doi = {10.1109/5.97300},
    institution = {Lab. de Genie Inf., Inst. IMAG, Grenoble, France},
    issn = {0018-9219},
    journal = {Proceedings of the IEEE},
    keywords = {synchronous-dataflow},
    month = sep,
    number = {9},
    pages = {1305--1320},
    posted-at = {2014-08-07 09:19:44},
    priority = {1},
    publisher = {IEEE},
    title = {The synchronous data flow programming language {LUSTRE}},
    url = {http://dx.doi.org/10.1109/5.97300},
    volume = {79},
    year = {1991}
}

@article{pouzet:lucid,
    author = {Pouzet, Marc},
    citeulike-article-id = {13317730},
    journal = {Tutorial and reference manual. Universit{\'{e}} Paris-Sud, LRI},
    keywords = {synchronous-dataflow},
    posted-at = {2014-08-07 09:18:29},
    priority = {1},
    title = {Lucid {S}ynchrone, version 3},
    year = {2006}
}

@article{berry:esterel,
    address = {3001 Leuven, Belgium, Belgium},
    author = {Berry, G\'{e}rard and Gonthier, Georges},
    booktitle = {DATE '06: Proceedings of the conference on Design, automation and test in Europe},
    citeulike-article-id = {897527},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1131643},
    citeulike-linkout-1 = {http://dx.doi.org/10.1016/0167-6423(92)90005-v},
    citeulike-linkout-2 = {http://www.sciencedirect.com/science/article/B6V17-45FCW68-H/2/5ee2f25cbfc68cd4a9345c4d5b55a284},
    doi = {10.1016/0167-6423(92)90005-v},
    isbn = {3981080106},
    issn = {01676423},
    journal = {Science of Computer Programming},
    keywords = {synchronous-dataflow},
    month = nov,
    number = {2},
    pages = {87--152},
    posted-at = {2014-08-07 09:16:23},
    priority = {1},
    publisher = {European Design and Automation Association},
    title = {The {E}sterel synchronous programming language: design, semantics, implementation},
    url = {http://dx.doi.org/10.1016/0167-6423(92)90005-v},
    volume = {19},
    year = {1992}
}

@inproceedings{neelk:bounded,
    abstract = {Functional reactive programming ({FRP}) is an elegant and successful approach to programming reactive systems declaratively. The high levels of abstraction and expressivity that make {FRP} attractive as a programming model do, however, often lead to programs whose resource usage is excessive and hard to predict. In this paper, we address the problem of space leaks in discrete-time functional reactive programs. We present a functional reactive programming language that statically bounds the size of the dataflow graph a reactive program creates, while still permitting use of higher-order functions and higher-type streams such as streams of streams. We achieve this with a novel linear type theory that both controls allocation and ensures that all recursive definitions are well-founded. We also give a denotational semantics for our language by combining recent work on metric spaces for the interpretation of higher-order causal functions with length-space models of space-bounded computation. The resulting category is doubly closed and hence forms a model of the logic of bunched implications.},
    address = {New York, NY, USA},
    author = {Krishnaswami, Neelakantan R. and Benton, Nick and Hoffmann, Jan},
    booktitle = {Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    citeulike-article-id = {12987375},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2103656.2103665},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2103656.2103665},
    doi = {10.1145/2103656.2103665},
    isbn = {978-1-4503-1083-3},
    keywords = {functional-programming, functional-reactive-programming, theory},
    location = {Philadelphia, PA, USA},
    pages = {45--58},
    posted-at = {2014-08-07 09:11:15},
    priority = {2},
    publisher = {ACM},
    series = {POPL '12},
    title = {Higher-order Functional Reactive Programming in Bounded Space},
    url = {http://dx.doi.org/10.1145/2103656.2103665},
    year = {2012}
}

@inproceedings{nilsson:afrp,
    abstract = {Functional Reactive Programming ({FRP}) extends a host programming language with a notion of time flow. Arrowized {FRP} ({AFRP}) is a version of {FRP} embedded in Haskell based on the arrow combinators. {AFRP} is a powerful synchronous dataflow programming language with hybrid modeling capabilities, combining advanced synchronous dataflow features with the higher-order lazy functional abstractions of Haskell. In this paper, we describe the {AFRP} programming style and our Haskell-based implementation. Of particular interest are the {AFRP} combinators that support dynamic collections and continuation-based switching. We show how these combinators can be used to express systems with an evolving structure that are difficult to model in more traditional dataflow languages.},
    address = {New York, NY, USA},
    author = {Nilsson, Henrik and Courtney, Antony and Peterson, John},
    booktitle = {Proceedings of the 2002 ACM SIGPLAN Workshop on Haskell},
    citeulike-article-id = {368184},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=581695},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/581690.581695},
    doi = {10.1145/581690.581695},
    isbn = {1-58113-605-6},
    keywords = {arrow-frp, functional-programming, functional-reactive-programming},
    location = {Pittsburgh, Pennsylvania},
    pages = {51--64},
    posted-at = {2014-08-06 16:58:29},
    priority = {2},
    publisher = {ACM},
    series = {Haskell '02},
    title = {Functional Reactive Programming, Continued},
    url = {http://dx.doi.org/10.1145/581690.581695},
    year = {2002}
}

@article{wan:frp,
    abstract = {Functional Reactive Programming, or {FRP}, is a general framework for programming hybrid systems in a high-level, declarative manner. The key ideas in {FRP} are its notions of behaviors and events. Behaviors are time-varying, reactive values, while events are time-ordered sequences of discrete-time event occurrences. {FRP} is the essence of Fran, a domain-specific language embedded in Haskell for programming reactive animations, but {FRP} is now also being used in vision, robotics and other control systems applications. In this paper we explore the formal semantics of {FRP} and how it
relates to an implementation based on streams that represent (and therefore only approximate) continuous behaviors. We show that, in the limit as the sampling interval goes to zero, the implementation is faithful to the formal, continuous semantics, but only when certain constraints on behaviors are observed. We explore the nature of these constraints, which vary amongst the {FRP} primitives. Our results show both the power and limitations of this approach to language design and implementation. As an example of a limitation, we show that streams are incapable of representing instantaneous predicate events over behaviors.},
    address = {New York, NY, USA},
    author = {Wan, Zhanyong and Hudak, Paul},
    booktitle = {PLDI '00: Proceedings of the ACM SIGPLAN 2000 conference on Programming language design and implementation},
    citeulike-article-id = {1825652},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=349331},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/349299.349331},
    doi = {10.1145/349299.349331},
    isbn = {1581131992},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {frp, functional, functional-reactive-programming},
    month = may,
    number = {5},
    pages = {242--252},
    posted-at = {2014-08-06 15:23:15},
    priority = {2},
    publisher = {ACM},
    title = {Functional Reactive Programming from First Principles},
    url = {http://dx.doi.org/10.1145/349299.349331},
    volume = {35},
    year = {2000}
}

@incollection{hudak:frp,
    abstract = {Functional reactive programming, or {FRP}, is a style of programming based on two key ideas: continuous time-varying behaviors, and event-based reactivity. {FRP} is the essence of Fran [1,2], a domain-specific language for functional reactive graphics and animation, and has recently been used in the design of Frob [3,4], a domain-specific language for functional vision and robotics. In general, {FRP} can be viewed as an interesting language for describing hybrid systems, which are systems comprised of both analog (continuous) and digital (discrete) subsystems. Continuous behaviors can be thought of simply as functions from time to some value: Behavior a = Time -> a. For example: an image behavior may represent an animation; a Cartesian-point behavior may be a mouse; a velocity-vector behavior may be the control vector for a robot; and a tuple-of-distances behavior may be the input from a robot's sonar array. Both continuous behaviors and event-based reactivity have interesting pro erties worthy of independent study, but their integration is particularly interesting. At the core of the issue is that events are intended to cause discrete shifts in declarative behavior; i.e. not just shifts in the state of reactivity. Being declarative, the natural desire is for everything to be first-class and higher-order. But this causes interesting clashes in frames of reference, especially when time and space transformations are applied. In this talk the fundamental ideas behind {FRP} are presented, along with a discussion of various issues in its formal semantics. This is joint work with Conal Elliot at Microsoft Research, and John Peterson at Yale.},
    address = {Berlin, Heidelberg},
    author = {Hudak, Paul},
    booktitle = {Programming Languages and Systems},
    chapter = {1},
    citeulike-article-id = {6594003},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/3-540-49099-x_1},
    citeulike-linkout-1 = {http://www.springerlink.com/content/g8tf9gamjgd6n9dr},
    citeulike-linkout-2 = {http://link.springer.com/chapter/10.1007/3-540-49099-X_1},
    day = {28},
    doi = {10.1007/3-540-49099-x_1},
    editor = {Swierstra},
    isbn = {978-3-540-65699-9},
    keywords = {functional, functional-programming, functional-reactive-programming},
    month = mar,
    pages = {1},
    posted-at = {2014-08-06 15:22:31},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Functional Reactive Programming},
    url = {http://dx.doi.org/10.1007/3-540-49099-x_1},
    volume = {1576},
    year = {1999}
}

@article{heer:declarative,
    author = {Heer, Jeffrey and Bostock, Michael},
    citeulike-article-id = {13316057},
    journal = {Visualization and Computer Graphics, IEEE Transactions on},
    keywords = {d3, hci, infovis},
    number = {6},
    pages = {1149--1156},
    posted-at = {2014-08-05 09:25:38},
    priority = {2},
    publisher = {IEEE},
    title = {Declarative {L}anguage {D}esign for {I}nteractive {V}isualization},
    volume = {16},
    year = {2010}
}

@article{bostock:d3,
    author = {Bostock, Michael and Ogievetsky, Vadim and Heer, Jeffrey},
    citeulike-article-id = {13316054},
    journal = {Visualization and Computer Graphics, IEEE Transactions on},
    keywords = {d3, hci, infovis},
    number = {12},
    pages = {2301--2309},
    posted-at = {2014-08-05 09:24:03},
    priority = {2},
    publisher = {IEEE},
    title = {D3: {D}ata-{D}riven {D}ocuments},
    volume = {17},
    year = {2011}
}

@incollection{hudak:afrp,
    author = {Hudak, Paul and Courtney, Antony and Nilsson, Henrik and Peterson, John},
    booktitle = {Advanced Functional Programming},
    citeulike-article-id = {13315591},
    keywords = {arrow-frp, dataflow, functional-programming, functional-reactive-programming},
    pages = {159--187},
    posted-at = {2014-08-04 17:39:41},
    priority = {4},
    publisher = {Springer},
    title = {Arrows, {R}obots, and {F}unctional {R}eactive {P}rogramming},
    year = {2003}
}

@techreport{scala-react,
    author = {Maier, Ingo and Rompf, Tiark and Odersky, Martin},
    citeulike-article-id = {13315585},
    keywords = {dataflow, functional, functional-programming, functional-reactive-programming},
    number = {EPFL-REPORT-148043},
    organization = {\'{E}cole Polytechnique F\`ed\`erale de Lausanne},
    posted-at = {2014-08-04 17:30:14},
    priority = {0},
    title = {Deprecating the {O}bserver {P}attern},
    year = {2010}
}

@inproceedings{elm-lang,
    address = {New York, NY, USA},
    author = {Czaplicki, Evan and Chong, Stephen},
    booktitle = {Proceedings of the 34th {ACM} {SIGPLAN} {C}onference on {P}rogramming {L}anguage {D}esign and {I}mplementation},
    citeulike-article-id = {13315582},
    citeulike-linkout-0 = {http://dx.doi.org/10.1145/2491956.2462161},
    doi = {10.1145/2491956.2462161},
    keywords = {elm, functional, functional-programming, functional-reactive-programming, graphical, interfaces, programming, reactive, user, web},
    location = {Seattle, Washington, USA},
    pages = {411--422},
    posted-at = {2014-08-04 17:24:08},
    priority = {0},
    publisher = {ACM},
    series = {PLDI '13},
    title = {{A}synchronous {F}unctional {R}eactive {P}rogramming for {GUI}s},
    url = {http://dx.doi.org/10.1145/2491956.2462161},
    year = {2013}
}

@incollection{flowlets,
    author = {Bjornson, Joel and Tayanovskyy, Anton and Granicz, Adam},
    booktitle = {Implementation and Application of Functional Languages},
    citeulike-article-id = {13315576},
    keywords = {formlets, fsharp, web-abstractions, web-programming},
    pages = {203--216},
    posted-at = {2014-08-04 17:18:33},
    priority = {0},
    publisher = {Springer},
    series = {IFL '10},
    title = {{C}omposing {R}eactive {GUI}s in {F}\# using {W}eb{S}harper},
    year = {2011}
}

@incollection{petricek:computation-expressions,
    author = {Petricek, Tomas and Syme, Don},
    booktitle = {Practical Aspects of Declarative Languages},
    citeulike-article-id = {13315575},
    keywords = {computation-expressions, fsharp},
    pages = {33--48},
    posted-at = {2014-08-04 17:16:55},
    priority = {0},
    publisher = {Springer},
    title = {The {F}\# {C}omputation {E}xpression {Z}oo},
    year = {2014}
}

@inproceedings{loic:piglets,
    author = {Denuzi\`{e}re, Lo\"{i}c and Rodriguez, Ernesto and Granicz, Adam},
    booktitle = {Proceedings of the 25th International Symposium on Implementation and Application of Functional Languages (IFL '13)},
    citeulike-article-id = {13315572},
    editor = {Plasmeijer, Rinus},
    howpublished = {To appear},
    keywords = {abstraction, form, functional, web-programming},
    posted-at = {2014-08-04 17:14:33},
    priority = {0},
    title = {Piglets to the {R}escue},
    year = {2013}
}

@inbook{conal:frp,
    abstract = {Fran (Functional Reactive Animation) is a collection of data
types and functions for composing richly interactive, multimedia
animations. The key ideas in Fran are its notions of
behaviors and events. Behaviors are time-varying, reactive
values, while events are sets of arbitrarily complex conditions,
carrying possibly rich information. Most traditional
values can be treated as behaviors, and when images are
thus treated, they become animations. Although these notions
are captured as data types ...},
    address = {New York, NY, USA},
    author = {Elliott, Conal and Hudak, Paul},
    booktitle = {Proceedings of the ACM {SIGPLAN} International Conference on Functional Programming},
    citeulike-article-id = {326289},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.7696},
    keywords = {functional, haskell, reactive},
    location = {Amsterdam, The Netherlands},
    pages = {263--273},
    posted-at = {2014-08-04 17:10:13},
    priority = {0},
    publisher = {ACM},
    series = {ICFP '97},
    title = {{Functional Reactive Animation}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.7696},
    volume = {32(8)},
    year = {1997}
}

@incollection{cooper:formlets,
    author = {Cooper, Ezra and Lindley, Sam and Wadler, Philip and Yallop, Jeremy},
    booktitle = {Programming Languages and Systems},
    citeulike-article-id = {13315566},
    pages = {205--220},
    posted-at = {2014-08-04 17:07:46},
    priority = {0},
    publisher = {Springer},
    title = {The {E}ssence of {F}orm {A}bstraction},
    year = {2008}
}

@inproceedings{gaertner:optimal,
    abstract = {Ant Colony Optimization ({ACO}) is a metaheuristic introduced by Dorigo et al. [9] which uses ideas from nature to find solutions to instances of the Travelling Salesman Problem ({TSP}) and other combinatorial optimisation problems. In this paper we analyse the parameter settings of the {ACO} algorithm. These determine the behaviour of each ant and are critical for fast convergence to near optimal solutions of a given problem instance. We classify {TSP} instances using three measures of complexity and uniformity. We describe experimental work that attempts to correlate \^{a}types \^{a} of {TSP} problems with parameter settings for fast convergence. We found these optimal parameter settings to be highly problemspecific and dependent on the required accuracy of the solution. This inspired us to explore techniques for automatically learning the optimal parameters for a given {TSP} instance. We devised and implemented a hybrid {ACO} algorithm, similar to the one independently developed in [16], which uses a genetic algorithm in the early stages to \^{a}breed \^{a} a population of ants possessing near optimal behavioural parameter settings for a given problem. This hybrid algorithm converges rapidly for a wide range of problems when given a population of ants with diverse behavioural parameter settings.},
    author = {Gaertner, Dorian and Clark, Keith},
    booktitle = {Proceedings of the International Conference on Artificial Intelligence 2005},
    citeulike-article-id = {13143587},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.96.6751},
    keywords = {aco},
    pages = {83--89},
    posted-at = {2014-04-21 23:05:04},
    priority = {0},
    title = {On Optimal Parameters for Ant Colony Optimization Algorithms},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.96.6751},
    year = {2005}
}

@article{tsplib,
    author = {Reinelt, Gerhard},
    citeulike-article-id = {13143585},
    journal = {ORSA Journal on Computing},
    keywords = {tsplib},
    number = {4},
    pages = {376--384},
    posted-at = {2014-04-21 23:00:03},
    priority = {0},
    publisher = {INFORMS},
    title = {{TSPLIB}--A traveling salesman problem library},
    volume = {3},
    year = {1991}
}

@article{randall:aco,
    author = {Randall, Marcus and Lewis, Andrew},
    citeulike-article-id = {13143583},
    citeulike-linkout-0 = {http://dx.doi.org/10.1006/jpdc.2002.1854},
    doi = {10.1006/jpdc.2002.1854},
    issn = {07437315},
    journal = {Journal of Parallel and Distributed Computing},
    keywords = {aco, parallelism},
    month = sep,
    number = {9},
    pages = {1421--1432},
    posted-at = {2014-04-21 22:58:10},
    priority = {0},
    title = {A Parallel Implementation of Ant Colony Optimization},
    url = {http://dx.doi.org/10.1006/jpdc.2002.1854},
    volume = {62},
    year = {2002}
}

@article{dorigo-aco,
    abstract = {The introduction of ant colony optimization ({ACO}) and to survey its most notable applications are discussed. Ant colony optimization takes inspiration from the forging behavior of some ant species. These ants deposit Pheromone on the ground in order to mark some favorable path that should be followed by other members of the colony. The model proposed by Deneubourg and co-workers for explaining the foraging behavior of ants is the main source of inspiration for the development of ant colony optimization. In {ACO} a number of artificial ants build solutions to an optimization problem and exchange information on their quality through a communication scheme that is reminiscent of the one adopted by real ants. {ACO} algorithms is introduced and all {ACO} algorithms share the same idea and the {ACO} is formalized into a meta-heuristics for combinatorial problems. It is foreseeable that future research on {ACO} will focus more strongly on rich optimization problems that include stochasticity.},
    address = {Universite? Libre de Bruxelles, Belgium},
    author = {Dorigo, M. and Birattari, M. and Stu?tzle, T.},
    citeulike-article-id = {1145653},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/ci-m.2006.248054},
    doi = {10.1109/ci-m.2006.248054},
    journal = {IEEE Comput. Intell. Mag.},
    keywords = {aco, ant},
    number = {4},
    pages = {28--39},
    posted-at = {2014-04-21 13:32:10},
    priority = {2},
    title = {Ant colony optimization artificial ants as a computational intelligence technique},
    url = {http://dx.doi.org/10.1109/ci-m.2006.248054},
    volume = {1},
    year = {2006}
}

@incollection{uppaal:tut,
    abstract = {This is a tutorial paper on the tool Uppaal. Its goal is to be a short introduction on the flavor of timed automata implemented in the tool, to present its interface, and to explain how to use the tool. The contribution of the paper is to provide reference examples and modeling patterns.},
    author = {Behrmann, Gerd and David, Alexandre and Larsen, KimG},
    booktitle = {Formal Methods for the Design of Real-Time Systems},
    citeulike-article-id = {13139982},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-540-30080-9_7},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-540-30080-9_7},
    doi = {10.1007/978-3-540-30080-9_7},
    editor = {Bernardo, Marco and Corradini, Flavio},
    keywords = {lsv, model-checking, timed-automata},
    pages = {200--236},
    posted-at = {2014-04-16 18:55:46},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {A Tutorial on Uppaal},
    url = {http://dx.doi.org/10.1007/978-3-540-30080-9_7},
    volume = {3185},
    year = {2004}
}

@inproceedings{lindahl:gear,
    abstract = {In this paper, we report on an application of the validation and verification tool kit Uppaal in the design and analysis of a prototype gear controller, carried out in a joint project between industry and academia. We give a detailed description of the formal model of the gear controller and its surrounding environment, and its correctness formalised according to the informal requirements delivered by our industrial partner of the project. The second contribution of this paper is a solution to the problem we met in this case study, namely how to use a tool like Uppaal, which only provides reachability analysis to verify bounded response time properties. The advantage of our solution is that we need no additional implementation work to extend the existing model-checker, but simple manual syntactical manipulation on the system description.},
    author = {Lindahl, Magnus and Pettersson, Paul and Yi, Wang},
    booktitle = {PROCEEDINGS OF 4TH INTERNATIONAL WORKSHOP ON TOOLS AND ALGORITHMS FOR THE CONSTRUCTION AND ANALYSIS OF SYSTEMS, VOLUME 1384 OF LECTURE NOTES IN COMPUTER SCIENCE},
    citeulike-article-id = {13139366},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.103.839},
    keywords = {industrial, lsv, model-checking, timed-automata, uppaal},
    pages = {281--297},
    posted-at = {2014-04-15 23:49:54},
    priority = {2},
    title = {Formal design and analysis of a gear controller},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.103.839},
    year = {1998}
}

@inproceedings{bowman:lipsync,
    abstract = {We present the formal specification and verification of a lip synchronisation algorithm using the real-time model checker {UPPAAL}. A number of specifications of this algorithm can be found in the literature, but this is the first automatic verification. We take a published specification of the algorithm, code it up in the {UPPAAL} timed automata notation and then verify whether the algorithm satisfies the key properties of jitter and skew. The verification reveals some flaws in the algorithm. In particular, it shows that for certain sound and video streams the algorithm can timelock before reaching a prescribed error state.},
    author = {Bowman, H. and Faconti, G. and Katoen, J. P. and Latella, D. and Massink, M.},
    booktitle = {Proc. of the 3rd International Workshop on Formal Methods for Industrial Critical Systems},
    citeulike-article-id = {13139362},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.697},
    keywords = {industrial, lsv, model-checking, timed-automata, uppaal},
    pages = {97--124},
    posted-at = {2014-04-15 23:27:17},
    priority = {2},
    title = {Automatic verification of a lip synchronisation algorithm using {UPPAAL}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.697},
    year = {1998}
}

@inproceedings{havelund:industrial,
    author = {Havelund, K. and Skou, A. and Larsen, K. G. and Lund, K.},
    booktitle = {Real-Time Systems Symposium, 1997. Proceedings., The 18th IEEE},
    citeulike-article-id = {13139355},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/real.1997.641264},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=641264},
    doi = {10.1109/real.1997.641264},
    institution = {BRICS, Aalborg Univ., Denmark},
    isbn = {0-8186-6600-5},
    issn = {1052-8725},
    keywords = {industry, lsv, model-checking, uppaal, verification},
    month = dec,
    pages = {2--13},
    posted-at = {2014-04-15 23:04:54},
    priority = {3},
    publisher = {IEEE},
    title = {Formal modeling and analysis of an audio/video protocol: an industrial case study using {UPPAAL}},
    url = {http://dx.doi.org/10.1109/real.1997.641264},
    year = {1997}
}

@article{larsen:uppaal,
    author = {Larsen, Kim G. and Pettersson, Paul and Yi, Wang},
    booktitle = {International Journal on Software Tools for Technology Transfer},
    citeulike-article-id = {9548210},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/s100090050010},
    citeulike-linkout-1 = {http://www.springerlink.com/content/efp38tmfymhd63yf},
    citeulike-linkout-2 = {http://link.springer.com/article/10.1007/s100090050010},
    day = {1},
    doi = {10.1007/s100090050010},
    issn = {1433-2779},
    journal = {International Journal on Software Tools for Technology Transfer (STTT)},
    keywords = {model-checking, timed-automata, uppaal},
    month = dec,
    number = {1-2},
    pages = {134--152},
    posted-at = {2014-04-15 23:01:32},
    priority = {0},
    publisher = {Springer-Verlag},
    title = {Uppaal in a nutshell},
    url = {http://dx.doi.org/10.1007/s100090050010},
    volume = {1},
    year = {1997}
}

@article{clarke:automatic,
    abstract = {We give an efficient procedure for verifying that a finite-state concurrent system meets a specification expressed in a (propositional, branching-time) temporal logic. Our algorithm has complexity linear in both the size of the specification and the size of the global state graph for the concurrent system. We also show how this approach can be adapted to handle fairness. We argue that our technique can provide a practical alternative to manual proof construction or use of a mechanical theorem prover for verifying many finite-state concurrent systems. Experimental results show that state machines with several hundred states can be checked in a matter of seconds.},
    address = {New York, NY, USA},
    author = {Clarke, E. M. and Emerson, E. A. and Sistla, A. P.},
    citeulike-article-id = {115216},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=5399},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/5397.5399},
    doi = {10.1145/5397.5399},
    issn = {0164-0925},
    journal = {ACM Trans. Program. Lang. Syst.},
    keywords = {lsv, model-checking, verification},
    month = apr,
    number = {2},
    pages = {244--263},
    posted-at = {2014-04-15 22:18:39},
    priority = {2},
    publisher = {ACM},
    title = {Automatic Verification of Finite-state Concurrent Systems Using Temporal Logic Specifications},
    url = {http://dx.doi.org/10.1145/5397.5399},
    volume = {8},
    year = {1986}
}

@incollection{larsen:rts,
    abstract = {Efficient automatic model-checking algorithms for real-time systems have been obtained in recent years based on the state-region graph technique of Alur, Courcoubetis and Dill. However, these algorithms are faced with two potential types of explosion arising from parallel composition: explosion in the space of control nodes, and explosion in the region space over clock-variables.
                          This paper reports on work attacking these explosion problems by developing and combining compositional and symbolic model-checking techniques. The presented techniques provide the foundation for a new automatic verification tool Uppaal. Experimental results show that Uppaal is not only substantially faster than other real-time verification tools but also able to handle much larger systems.},
    author = {Larsen, KimG and Pettersson, Paul and Yi, Wang},
    booktitle = {Fundamentals of Computation Theory},
    citeulike-article-id = {13139242},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/3-540-60249-6_41},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/3-540-60249-6_41},
    doi = {10.1007/3-540-60249-6_41},
    editor = {Reichel, Horst},
    keywords = {lsv, model-checking, timed-automata, verification},
    pages = {62--88},
    posted-at = {2014-04-15 22:17:06},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Model-checking for real-time systems},
    url = {http://dx.doi.org/10.1007/3-540-60249-6_41},
    volume = {965},
    year = {1995}
}

@inproceedings{alur:rts,
    author = {Alur, R. and Courcoubetis, C. and Dill, D.},
    booktitle = {Logic in Computer Science, 1990. LICS \&\#039;90, Proceedings., Fifth Annual IEEE Symposium on e},
    citeulike-article-id = {13139240},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/lics.1990.113766},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=113766},
    doi = {10.1109/lics.1990.113766},
    institution = {Dept. of Comput. Sci., Stanford Univ., CA, USA},
    isbn = {0-8186-2073-0},
    keywords = {lsv, model-checking, verification},
    month = jun,
    pages = {414--425},
    posted-at = {2014-04-15 22:15:12},
    priority = {0},
    publisher = {IEEE},
    title = {Model-checking for real-time systems},
    url = {http://dx.doi.org/10.1109/lics.1990.113766},
    year = {1990}
}

@article{trinder:strategies,
    abstract = {The process of writing large parallel programs is complicated by the need to specify both the parallel behaviour of the program and the algorithm that is to be used to compute its result. This paper introduces evaluation strategies, lazy higher-order functions that control the parallel evaluation of non-strict functional languages. Using evaluation strategies, it is possible to achieve a clean separation between algorithmic and behavioural code. The result is enhanced clarity and shorter parallel programs. Evaluation strategies are a very general concept: this paper shows how they can be used to model a wide range of commonly used programming paradigms, including divideand-conquer, pipeline parallelism, producer/consumer parallelism, and data-oriented parallelism. Because they are based on unrestricted higher-order functions, they can also capture irregular parallel structures. Evaluation strategies are not just of theoretical interest: they have evolved out of our experience in parallelising several large-scale parallel applications, where they have proved invaluable in helping to manage the complexities of parallel behaviour. Some of these applications are described in detail here. The largest application we have studied to date, Lolita, is a 60,000 line natural language engineering system. Initial results show that for these programs we can achieve acceptable parallel performance, for relatively little programming effort. 1 Writing Parallel Programs While it is hard to write good sequential programs, it can be considerably harder to write good parallel ones. At Glasgow we have worked on several fairly large parallel programming projects and have slowly, and sometimes painfully, developed a methodology for parallelising sequential programs. The essence of the problem facing the parallel programmer is that, in addition to specifying what value the program should compute, explicitly parallel programs},
    author = {Trinder, P. W. and Hammond, K. and -W and {S. L} and Jones, Peyton},
    citeulike-article-id = {3270982},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.1628},
    journal = {Journal of Functional Programming},
    keywords = {algorithm, parallelism, strategy},
    pages = {23--60},
    posted-at = {2014-04-08 23:45:08},
    priority = {2},
    title = {Algorithm + Strategy = Parallelism},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.1628},
    volume = {8},
    year = {1998}
}

@article{lindley:sessions,
    author = {Lindley, Sam and Morris, J. Garrett},
    booktitle = {{6th International Workshop on Programming Language Approaches to Concurrency and Communication-cEntric Software}},
    citeulike-article-id = {13114399},
    howpublished = {To appear},
    keywords = {abcd, linear-logic, session-types},
    posted-at = {2014-03-22 20:30:23},
    priority = {3},
    title = {Sessions as propositions},
    year = {2014}
}

@article{rfc2535,
    author = {Eastlake, D.},
    citeulike-article-id = {13114374},
    howpublished = {\url{https://www.ietf.org/rfc/rfc2535.txt}},
    keywords = {dns, network, rfc},
    posted-at = {2014-03-22 19:58:45},
    priority = {0},
    title = {{RFC} {2535--Domain} Name System Security Extensions},
    year = {1999}
}

@article{rfc1035,
    author = {Mockapetris, Paul},
    citeulike-article-id = {13114372},
    howpublished = {\url{http://www.ietf.org/rfc/rfc1035.txt}},
    keywords = {dns, network, rfc},
    posted-at = {2014-03-22 19:57:50},
    priority = {0},
    title = {{RFC} {1035—Domain} names—implementation and specification},
    year = {1987}
}

@article{ocaml,
    author = {Leroy, Xavier},
    citeulike-article-id = {13114320},
    howpublished = {\\url{http://caml. inria. fr/ocaml/index. en. html}},
    keywords = {ocaml},
    posted-at = {2014-03-22 18:06:28},
    priority = {2},
    title = {The {OCaml} programming language},
    year = {1998}
}

@article{lindley:handlers,
    abstract = {Plotkin and Pretnar's handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, algebraic effects provide a high degree of modularity, allowing programmers to express effectful programs independently of the concrete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types. This is a position paper whose main aim is to popularise the handler abstraction. We give a gentle introduction to its use, a collection of illustrative examples, and a straightforward operational semantics. We describe our Haskell implementation of handlers in detail, outline the ideas behind our {OCaml}, {SML}, and Racket implementations, and present experimental results comparing handlers with existing code.},
    address = {New York, NY, USA},
    author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
    citeulike-article-id = {13113988},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2500590},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2544174.2500590},
    doi = {10.1145/2544174.2500590},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {algebraic-effects, effects, handlers},
    month = sep,
    number = {9},
    pages = {145--158},
    posted-at = {2014-03-21 23:50:23},
    priority = {4},
    publisher = {ACM},
    title = {Handlers in Action},
    url = {http://dx.doi.org/10.1145/2544174.2500590},
    volume = {48},
    year = {2013}
}

@inproceedings{fowler:idrisweb,
    author = {Simon Fowler and Edwin Brady},
    booktitle = {Implementation and Application of Functional Languages},
    citeulike-article-id = {13113041},
    editor = {Plasmeijer, Rinus},
    howpublished = {To appear},
    keywords = {database, dependent-types, effects, web-programming},
    posted-at = {2014-03-21 02:34:39},
    priority = {0},
    title = {Dependent Types for Safe and Secure Web Programming},
    year = {2013}
}

@inproceedings{yorgey:datakinds,
    abstract = {Static type systems strive to be richly expressive while still being simple enough for programmers to use. We describe an experiment that enriches Haskell's kind system with two features promoted from its type system: data types and polymorphism. The new system has a very good power-to-weight ratio: it offers a significant improvement in expressiveness, but, by re-using concepts that programmers are already familiar with, the system is easy to understand and implement.},
    address = {New York, NY, USA},
    author = {Yorgey, Brent A. and Weirich, Stephanie and Cretin, Julien and Jones, Simon P. and Vytiniotis, Dimitrios and Jos{\'{e}} Pedro Magalh {a}es},
    booktitle = {Proceedings of the 8th ACM SIGPLAN Workshop on Types in Language Design and Implementation},
    citeulike-article-id = {12475145},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2103795},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2103786.2103795},
    doi = {10.1145/2103786.2103795},
    isbn = {978-1-4503-1120-5},
    keywords = {data-kinds, dependent-types, haskell},
    location = {Philadelphia, Pennsylvania, USA},
    pages = {53--66},
    posted-at = {2014-03-21 02:11:46},
    priority = {2},
    publisher = {ACM},
    series = {TLDI '12},
    title = {Giving Haskell a Promotion},
    url = {http://dx.doi.org/10.1145/2103786.2103795},
    year = {2012}
}

@article{mcbride:she,
    abstract = {Dependent types reflect the fact that validity of data is often a relative notion by allowing prior data to affect the types of subsequent data. Not only does this make for a precise type system, but also a highly generic one: both the type and the program for each instance of a family of operations can be computed from the data which codes for that instance. Recent experimental extensions to the Haskell type class mechanism give us strong tools to relativize types to other types. We may simulate some aspects of dependent typing by making counterfeit type-level copies of data, with type constructors simulating data constructors and type classes simulating datatypes. This paper gives examples of the technique and discusses its potential.},
    address = {New York, NY, USA},
    author = {McBride, Conor},
    citeulike-article-id = {271354},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=968421},
    citeulike-linkout-1 = {http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=114969},
    citeulike-linkout-2 = {http://dx.doi.org/10.1017/s0956796802004355},
    doi = {10.1017/s0956796802004355},
    issn = {1469-7653},
    journal = {Journal of Functional Programming},
    keywords = {dependent-types, haskell, mcbride, she},
    month = jul,
    number = {5},
    pages = {375--392},
    posted-at = {2014-03-21 01:55:44},
    priority = {2},
    publisher = {Cambridge University Press},
    title = {Faking it Simulating dependent types in Haskell},
    url = {http://dx.doi.org/10.1017/s0956796802004355},
    volume = {12},
    year = {2002}
}

@article{spj:gadts,
    abstract = {Generalized algebraic data types ({GADTs}), sometimes known as "guarded recursive data types" or "first-class phantom types", are a simple but powerful generalization of the data types of Haskell and {ML}. Recent works have given compelling examples of the utility of {GADTs}, although type inference is known to be difficult. Our contribution is to show how to exploit programmer-supplied type annotations to make the type inference task almost embarrassingly easy. Our main technical innovation is wobbly types, which express in a declarative way the uncertainty caused by the incremental nature of typical type-inference algorithms.},
    address = {New York, NY, USA},
    author = {Jones, Simon P. and Vytiniotis, Dimitrios and Weirich, Stephanie and Washburn, Geoffrey},
    citeulike-article-id = {2629664},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1160074.1159811},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1160074.1159811},
    doi = {10.1145/1160074.1159811},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {dependent-types, gadts, haskell},
    month = sep,
    number = {9},
    pages = {50--61},
    posted-at = {2014-03-21 01:28:35},
    priority = {2},
    publisher = {ACM},
    title = {Simple Unification-based Type Inference for {GADTs}},
    url = {http://dx.doi.org/10.1145/1160074.1159811},
    volume = {41},
    year = {2006}
}

@inproceedings{lindley:hasochism,
    abstract = {Haskell's type system has outgrown its {Hindley-Milner} roots to the extent that it now stretches to the basics of dependently typed programming. In this paper, we collate and classify techniques for programming with dependent types in Haskell, and contribute some new ones. In particular, through extended examples---merge-sort and rectangular tilings---we show how to exploit Haskell's constraint solver as a theorem prover, delivering code which, as Agda programmers, we envy. We explore the compromises involved in simulating variations on the theme of the dependent function space in an attempt to help programmers put dependent types to work, and to inform the evolving language design both of Haskell and of dependently typed languages more broadly.},
    address = {New York, NY, USA},
    author = {Lindley, Sam and McBride, Conor},
    booktitle = {Proceedings of the 2013 ACM SIGPLAN Symposium on Haskell},
    citeulike-article-id = {13112783},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2503778.2503786},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2503778.2503786},
    doi = {10.1145/2503778.2503786},
    isbn = {978-1-4503-2383-3},
    keywords = {dependent-types, haskell, hasochism},
    location = {Boston, Massachusetts, USA},
    pages = {81--92},
    posted-at = {2014-03-21 00:32:26},
    priority = {0},
    publisher = {ACM},
    series = {Haskell '13},
    title = {Hasochism: The Pleasure and Pain of Dependently Typed Haskell Programming},
    url = {http://dx.doi.org/10.1145/2503778.2503786},
    year = {2013}
}

@article{brady:effects,
    abstract = {One often cited benefit of pure functional programming is that pure code is easier to test and reason about, both formally and informally. However, real programs have side-effects including state management, exceptions and interactions with the outside world. Haskell solves this problem using monads to capture details of possibly side-effecting computations --- it provides monads for capturing state, {I/O}, exceptions, non-determinism, libraries for practical purposes such as {CGI} and parsing, and many others, as well as monad transformers for combining multiple effects. Unfortunately, useful as monads are, they do not compose very well. Monad transformers can quickly become unwieldy when there are lots of effects to manage, leading to a temptation in larger programs to combine everything into one coarse-grained state and exception monad. In this paper I describe an alternative approach based on handling algebraic effects, implemented in the {IDRIS} programming language. I show how to describe side effecting computations, how to write programs which compose multiple fine-grained effects, and how, using dependent types, we can use this approach to reason about states in effectful programs.},
    address = {New York, NY, USA},
    author = {Brady, Edwin},
    booktitle = {Proceedings of the 18th ACM SIGPLAN international conference on Functional programming},
    citeulike-article-id = {12691146},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2500581},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2500365.2500581},
    doi = {10.1145/2500365.2500581},
    isbn = {978-1-4503-2326-0},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {algebraic-effects, dependent-types, effects, idris},
    location = {Boston, Massachusetts, USA},
    month = sep,
    number = {9},
    pages = {133--144},
    posted-at = {2014-03-20 22:20:30},
    priority = {0},
    publisher = {ACM},
    series = {ICFP '13},
    title = {Programming and Reasoning with Algebraic Effects and Dependent Types},
    url = {http://dx.doi.org/10.1145/2500365.2500581},
    volume = {48},
    year = {2013}
}

@incollection{plotkin:effects,
    abstract = {We present an algebraic treatment of exception handlers and, more generally, introduce handlers for other computational effects representable by an algebraic theory. These include nondeterminism, interactive input/output, concurrency, state, time, and their combinations; in all cases the computation monad is the free-model monad of the theory. Each such handler corresponds to a model of the theory for the effects at hand. The handling construct, which applies a handler to a computation, is based on the one introduced by Benton and Kennedy, and is interpreted using the homomorphism induced by the universal property of the free model. This general construct can be used to describe previously unrelated concepts from both theory and practice.},
    address = {Berlin, Heidelberg},
    author = {Plotkin, Gordon and Pretnar, Matija},
    booktitle = {Programming Languages and Systems},
    citeulike-article-id = {9848514},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1532984},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/978-3-642-00590-9_7},
    citeulike-linkout-2 = {http://link.springer.com/chapter/10.1007/978-3-642-00590-9_7},
    doi = {10.1007/978-3-642-00590-9_7},
    editor = {Castagna, Giuseppe},
    isbn = {978-3-642-00589-3},
    keywords = {algebraic-effects, effects},
    location = {York, UK},
    pages = {80--94},
    posted-at = {2014-03-20 21:59:13},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Handlers of Algebraic Effects},
    url = {http://dx.doi.org/10.1007/978-3-642-00590-9_7},
    volume = {5502},
    year = {2009}
}

@inproceedings{liang:monadtrans,
    author = {Liang, Sheng and Hudak, Paul and Jones, Mark},
    booktitle = {Proceedings of the 22nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
    citeulike-article-id = {13112638},
    keywords = {effect, haskell, monad, monad-transformer},
    organization = {ACM},
    pages = {333--343},
    posted-at = {2014-03-20 19:54:06},
    priority = {2},
    title = {Monad transformers and modular interpreters},
    year = {1995}
}

@article{brady:idris-jfp13,
    abstract = {Many components of a dependently typed programming language are by now well understood, for example, the underlying type theory, type checking, unification and evaluation. How to combine these components into a realistic and usable high-level language is, however, folklore, discovered anew by successive language implementors. In this paper, I describe the implementation of Idris, a new dependently typed functional programming language. Idris is intended to be a general-purpose programming language and as such provides high-level concepts such as implicit syntax, type classes and do notation. I describe the high-level language and the underlying type theory, and present a tactic-based method for elaborating concrete high-level syntax with implicit arguments and type classes into a fully explicit type theory. Furthermore, I show how this method facilitates the implementation of new high-level language constructs.},
    author = {Brady, Edwin},
    citeulike-article-id = {13112547},
    citeulike-linkout-0 = {http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=9060502},
    citeulike-linkout-1 = {http://dx.doi.org/10.1017/s095679681300018x},
    doi = {10.1017/s095679681300018x},
    issn = {1469-7653},
    journal = {Journal of Functional Programming},
    keywords = {dependent-types, design, idris, implementation, type-theory},
    month = sep,
    pages = {552--593},
    posted-at = {2014-03-20 17:15:41},
    priority = {0},
    title = {Idris, a general-purpose dependently typed programming language: Design and implementation},
    url = {http://dx.doi.org/10.1017/s095679681300018x},
    volume = {23},
    year = {2013}
}

@phdthesis{brady:thesis,
    author = {Brady, Edwin C.},
    citeulike-article-id = {13112543},
    keywords = {dependent-types, erasure},
    posted-at = {2014-03-20 17:03:52},
    priority = {2},
    school = {Durham University},
    title = {Practical Implementation of a Dependently Typed Functional Programming Language},
    year = {2005}
}

@article{vinoski:corba,
    abstract = {Large computer networks such as corporate intranets and the
Internet are inherently heterogeneous due to such factors as
increasingly rapid technological change, engineering trade-offs,
accumulation of legacy systems over time, and varying system costs.
Unfortunately, such heterogeneity makes the development and maintenance
of applications that make the best use of such networks difficult. The
Common Object Request Broker Architecture specification created by the
Object Management Group provides a stable model for distributed
object-oriented systems that helps developers cope with heterogeneity
and inevitable change. Applications written to the {CORBA} standard are
abstracted away from underlying networking protocols and transports,
instead relying on object request brokers to provide a fast and flexible
communication and object activation substrated. The abstractions
provided by {CORBA} {ORBs} are currently serving as the basis for
applications in a wide variety of problem domains, including
telecommunications, finance, medicine, and manufacturing, running on
platforms ranging from mainframes down to test and measurement
equipment. This article first provides an overview of the Object
Management Architecture, then describes in detail the {CORBA} component of
that architecture, and concludes with a description of the {OMG}
organization along with some of its current and future work},
    author = {Vinoski, S.},
    citeulike-article-id = {777709},
    citeulike-linkout-0 = {http://dx.doi.org/10.1109/35.565655},
    citeulike-linkout-1 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=565655},
    doi = {10.1109/35.565655},
    issn = {01636804},
    journal = {IEEE Communications Magazine},
    keywords = {corba, middleware},
    month = feb,
    number = {2},
    pages = {46--55},
    posted-at = {2014-03-20 16:57:07},
    priority = {2},
    title = {{CORBA}: integrating diverse applications within distributed heterogeneous environments},
    url = {http://dx.doi.org/10.1109/35.565655},
    volume = {35},
    year = {1997}
}

@techreport{leijen:parsec,
    author = {Leijen, Daan and Meijer, Erik},
    citeulike-article-id = {13112497},
    institution = {Technical Report UU-CS-2001-27, Department of Computer Science, Universiteit Utrecht},
    keywords = {haskell, monadic, parsec, parser},
    posted-at = {2014-03-20 15:35:08},
    priority = {2},
    title = {Parsec: Direct style monadic parser combinators for the real world},
    year = {2001}
}

@article{mcbride:applicative,
    abstract = {In this article, we introduce Applicative functors – an abstract characterisation of an applicative style of effectful programming, weaker than Monads and hence more widespread. Indeed, it is the ubiquity of this programming pattern that drew us to the abstraction. We retrace our steps in this article, introducing the applicative pattern by diverse examples, then abstracting it to define the Applicative type class and introducing a bracket notation that interprets the normal application syntax in the idiom of an Applicative functor. Furthermore, we develop the properties of applicative functors and the generic operations they support. We close by identifying the categorical structure of applicative functors and examining their relationship both with Monads and with Arrow.},
    author = {Mc{B}ride, Conor and Paterson, Ross},
    citeulike-article-id = {2408154},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1348940.1348941},
    citeulike-linkout-1 = {http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=1457852},
    citeulike-linkout-2 = {http://dx.doi.org/10.1017/s0956796807006326},
    day = {16},
    doi = {10.1017/s0956796807006326},
    journal = {Journal of Functional Programming},
    keywords = {applicative, haskell},
    month = may,
    number = {01},
    pages = {1--13},
    posted-at = {2014-03-19 21:45:42},
    priority = {0},
    title = {Applicative {P}rogramming with {E}ffects},
    url = {http://dx.doi.org/10.1017/s0956796807006326},
    volume = {18},
    year = {2007}
}

@electronic{brady:interactive,
    author = {Brady, Edwin},
    citeulike-article-id = {13110994},
    howpublished = {http://edwinb.wordpress.com/2013/10/28/interactive-idris-editing-with-vim/},
    keywords = {dependent-types, idris, interactive-editing},
    posted-at = {2014-03-19 16:23:24},
    priority = {0},
    title = {Interactive Idris Editing with Vim}
}

@electronic{wikimedia:rad,
    author = {{The Wikimedia Foundation}},
    citeulike-article-id = {13110948},
    howpublished = {\url{http://en.wikipedia.org/wiki/File:RADModel.JPG}},
    keywords = {diagram, software-engineering},
    posted-at = {2014-03-19 14:54:36},
    priority = {2},
    title = {{Rapid Application Development}}
}

@electronic{wikimedia:iterative,
    author = {{The Wikimedia Foundation}},
    citeulike-article-id = {13110925},
    howpublished = {\url{http://en.wikipedia.org/wiki/File:Iterative\_development\_model\_V2.jpg}},
    keywords = {diagram, software-engineering},
    posted-at = {2014-03-19 14:32:19},
    priority = {2},
    title = {{Iterative Development Model}}
}

@book{martin:rad,
    address = {Indianapolis, IN, USA},
    author = {Martin, James},
    citeulike-article-id = {13110914},
    keywords = {rapid-application-development, software-engineering},
    posted-at = {2014-03-19 14:09:33},
    priority = {1},
    publisher = {Macmillan Publishing Co., Inc.},
    title = {Rapid Application Development},
    year = {1991}
}

@inproceedings{lamport:sometime,
    abstract = {Pnueli [15] has recently introduced the idea of using temporal logic [18] as the logical basis for proving correctness properties of concurrent programs. This has permitted an elegant unifying formulation of previous proof methods. In this paper, we attempt to clarify the logical foundations of the application of temporal logic to concurrent programs. In doing so, we will also clarify the relation between concurrency and nondeterminism, and identify some problems for further {research.In} this paper, we consider logics containing the temporal operators "henceforth" (or "always") and "eventually" (or "sometime"). We define the semantics of such a temporal logic in terms of an underlying model that abstracts the fundamental concepts common to almost all the models of computation which have been used. We are concerned mainly with the semantics of temporal logic, and will not discuss in any detail the actual rules for deducing {theorems.We} will describe two different temporal logics for reasoning about a computational model. The same formulas appear in both logics, but they are interpreted differently. The two interpretations correspond to two different ways of viewing time: as a continually branching set of possibilities, or as a single linear sequence of actual events. The temporal concepts of "sometime" and "not never" ("not always not") are equivalent in the theory of linear time, but not in the theory of branching time -- hence, our title. We will argue that the logic of linear time is better for reasoning about concurrent programs, and the logic of branching time is better for reasoning about nondeterministic {programs.The} logic of linear time was used by Pnueli in [15], while the logic of branching time seems to be the one used by most computer scientists for reasoning about temporal concepts. We have found this to cause some confusion among our colleagues, so one of our goals has been to clarify the formal foundations of Pnueli's {work.The} following section gives an intuitive discussion of temporal logic, and Section 3 formally defines the semantics of the two temporal logics. In Section 4, we prove that the two temporal logics are not equivalent, and discuss their differences. Section 5 discusses the problems of validity and completeness for the temporal logics. In Section 6, we show that there are some important properties of the computational model that cannot be expressed with the temporal operators "henceforth" and "eventually", and define more general operators.},
    address = {New York, NY, USA},
    author = {Lamport, Leslie},
    booktitle = {Proceedings of the 7th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    citeulike-article-id = {697234},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=567446.567463},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/567446.567463},
    doi = {10.1145/567446.567463},
    isbn = {0-89791-011-7},
    keywords = {logic, ltl, model-checking},
    location = {Las Vegas, Nevada},
    pages = {174--185},
    posted-at = {2014-03-13 16:47:34},
    priority = {2},
    publisher = {ACM},
    series = {POPL '80},
    title = {"Sometime" is Sometimes "Not Never": On the Temporal Logic of Programs},
    url = {http://dx.doi.org/10.1145/567446.567463},
    year = {1980}
}

@article{oury:powerofpi,
    abstract = {This paper exhibits the power of programming with dependent types by dint of embedding three domain-specific languages: Cryptol, a language for cryptographic protocols; a small data description language; and relational algebra. Each example demonstrates particular design patterns inherent to dependently-typed programming. Documenting these techniques paves the way for further research in domain-specific embedded type systems.},
    address = {New York, NY, USA},
    author = {Oury, Nicolas and Swierstra, Wouter},
    citeulike-article-id = {4075194},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1411203.1411213},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1411203.1411213},
    doi = {10.1145/1411203.1411213},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {dependent-types, universes},
    month = sep,
    number = {9},
    pages = {39--50},
    posted-at = {2014-03-12 11:49:11},
    priority = {0},
    publisher = {ACM},
    title = {The Power of Pi},
    url = {http://dx.doi.org/10.1145/1411203.1411213},
    volume = {43},
    year = {2008}
}

@incollection{dybjer:induction-recursion,
    abstract = {Induction-recursion is a schema which formalizes the principles for introducing new sets in {Martin-L\"{o}f} 's type theory. It states that we may inductively define a set while simultaneously defining a function from this set into an arbitrary type by structural recursion. This extends the notion of an inductively defined set substantially and allows us to introduce universes and higher order universes (but not a Mahlo universe). In this article we give a finite axiomatization of inductive-recursive definitions. We prove consistency by constructing a set-theoretic model which makes use of one Mahlo cardinal.},
    author = {Dybjer, Peter and Setzer, Anton},
    booktitle = {Typed Lambda Calculi and Applications},
    citeulike-article-id = {6172018},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/3-540-48959-2_11},
    citeulike-linkout-1 = {http://www.springerlink.com/content/3jh2ktddmanl2b61},
    citeulike-linkout-2 = {http://link.springer.com/chapter/10.1007/3-540-48959-2_11},
    doi = {10.1007/3-540-48959-2_11},
    editor = {Girard, Jean-Yves},
    journal = {Typed Lambda Calculi and Applications},
    keywords = {dependent-types, induction-recursion},
    pages = {129--146},
    posted-at = {2014-03-09 14:23:50},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {A Finite Axiomatization of {Inductive-Recursive} Definitions},
    url = {http://dx.doi.org/10.1007/3-540-48959-2_11},
    volume = {1581},
    year = {1999}
}

@article{holzmann:improved,
    abstract = {An automated analysis of all reachable states in a distributed system can be used to trace obscure logical errors that would be very hard to find manually. This type of validation is traditionally performed by the symbolic execution of a finite state machine ({FSM}) model of the system studied. The application of this method to systems of a practical size, though, is complicated by time and space requirements. If a system is larger, more space is needed to store the state descriptions and more time is needed to compare and analyze these states. This paper shows that if the {FSM} model is abandoned and replaced by a state vector model significant gains in performance are feasible, for the first time making it possible to perform effective validations of large systems.},
    author = {Holzmann, Gerard J.},
    citeulike-article-id = {13096869},
    citeulike-linkout-0 = {http://dx.doi.org/10.1002/spe.4380180203},
    day = {1},
    doi = {10.1002/spe.4380180203},
    journal = {Softw: Pract. Exper.},
    keywords = {lsv, model-checking, spin},
    month = feb,
    number = {2},
    pages = {137--161},
    posted-at = {2014-03-07 20:51:23},
    priority = {0},
    publisher = {John Wiley \& Sons, Ltd.},
    title = {An improved protocol reachability analysis technique},
    url = {http://dx.doi.org/10.1002/spe.4380180203},
    volume = {18},
    year = {1988}
}

@inproceedings{holzmann:improvement,
    abstract = {An abstract is not available.},
    address = {London, UK, UK},
    author = {Holzmann, Gerard J. and Peled, Doron},
    booktitle = {Proceedings of the 7th IFIP WG6.1 International Conference on Formal Description Techniques VII},
    citeulike-article-id = {3615615},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=681369},
    isbn = {0-412-64450-9},
    keywords = {lsv, model-checking, spin},
    pages = {197--211},
    posted-at = {2014-03-07 20:50:04},
    priority = {0},
    publisher = {Chapman \&amp; Hall, Ltd.},
    title = {An Improvement in Formal Verification},
    url = {http://portal.acm.org/citation.cfm?id=681369},
    year = {1995}
}

@article{holzmann:marscode,
    abstract = {Redundant software (and hardware) ensured Curiosity reached its destination and functioned as its designers intended.},
    address = {New York, NY, USA},
    author = {Holzmann, Gerard J.},
    citeulike-article-id = {13057048},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=2556647.2560218},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/2560217.2560218},
    doi = {10.1145/2560217.2560218},
    issn = {0001-0782},
    journal = {Commun. ACM},
    keywords = {lsv, model-checking, spin, verification},
    month = feb,
    number = {2},
    pages = {64--73},
    posted-at = {2014-03-07 20:14:47},
    priority = {2},
    publisher = {ACM},
    title = {Mars Code},
    url = {http://dx.doi.org/10.1145/2560217.2560218},
    volume = {57},
    year = {2014}
}

@article{holzmann:multicore,
    author = {Holzmann, Gerard J. and Bosnacki, Dragan},
    citeulike-article-id = {4813582},
    citeulike-linkout-0 = {http://dblp.uni-trier.de/rec/bibtex/journals/tse/HolzmannB07},
    citeulike-linkout-1 = {http://dx.doi.org/10.1109/tse.2007.70724},
    citeulike-linkout-2 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4302778},
    doi = {10.1109/tse.2007.70724},
    journal = {IEEE Trans. Software Eng.},
    keywords = {lsv, model-checking, multicore, parallelism, spin},
    number = {10},
    pages = {659--674},
    posted-at = {2014-03-07 20:01:15},
    priority = {2},
    title = {The Design of a Multicore Extension of the {SPIN} Model Checker},
    url = {http://dx.doi.org/10.1109/tse.2007.70724},
    volume = {33},
    year = {2007}
}

@inproceedings{holzmann:on-limits,
    author = {Holzmann, Gerard J.},
    booktitle = {Proceedings of the IFIP WG6. 1 Seventh International Conference on Protocol Specification, Testing and Verification VII},
    citeulike-article-id = {13096507},
    keywords = {holzmannon-limits},
    organization = {North-Holland Publishing Co.},
    pages = {339--344},
    posted-at = {2014-03-07 13:48:46},
    priority = {2},
    title = {On Limits and Possibilities of Automated Protocol Analysis},
    year = {1987}
}

@article{holzmann:bitstate,
    abstract = {The bitstate hashing, or supertrace, technique was introduced in 1987 as a method to increase the quality of verification by reachability analyses for applications that defeat analysis by traditional means because of their size. Since then, the technique has been included in many research verification tools, and was adopted in tools that are marketed commercially. It is therefore important that we understand well how and why the method works, what its limitations are, and how it compares with alternative methods over a broad range of problem sizes.
                            The original motivation for the bitstate hashing technique was based on empirical evidence of its effectiveness. In this paper we provide an analytical argument. We compare the technique with two alternatives that have been proposed in the recent literature. We also describe a sequential bitstate hashing technique that can be of value when confronted with very large problem sizes.},
    author = {Holzmann, Gerard J.},
    booktitle = {Formal Methods in System Design},
    citeulike-article-id = {13096504},
    citeulike-linkout-0 = {http://dx.doi.org/10.1023/a%253a1008696026254},
    citeulike-linkout-1 = {http://link.springer.com/article/10.1023/A%3A1008696026254},
    doi = {10.1023/a%253a1008696026254},
    keywords = {lsv, model-checking, spin},
    number = {3},
    pages = {289--307},
    posted-at = {2014-03-07 13:42:09},
    priority = {2},
    publisher = {Kluwer Academic Publishers},
    title = {An Analysis of Bitstate Hashing},
    url = {http://dx.doi.org/10.1023/a%253a1008696026254},
    volume = {13},
    year = {1998}
}

@article{holzmann:coverage,
    abstract = {We study the effect of three new reduction strategies for conventional reachability analysis, as used in automated protocol validation algorithms. The first two strategies are implementations of partial order semantics rules that attempt to minimize the number of execution sequences that need to be explored for a full state space exploration. The third strategy is the implementation of a state compression scheme that attempts to minimize the amount of memory that is used to built a state space. The three strategies are shown to have a potential for substantially improving the performance of a conventional search. The paper discusses the optimal choices for reducing either run time or memory requirements by four to six times. The strategies can readily be combined with each other and with alternative state space reduction techniques such as supertrace or state space caching methods.},
    author = {Holzmann, Gerard J. and Godefroid, Patrice and Pirottin, Didier},
    citeulike-article-id = {13096487},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.147.5045},
    keywords = {lsv, model-checking, spin},
    posted-at = {2014-03-07 13:15:15},
    priority = {2},
    title = {Coverage Preserving Reduction Strategies for Reachability Analysis},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.147.5045}
}

@incollection{peled:partial,
    abstract = {Partial order model-checking is an approach to reduce time and memory in model-checking concurrent programs. On-the-fly model-checking is a technique to eliminate part of the search by intersecting the (negation of the) checked property with the state space during its generation. We prove conditions under which these two methods can be combined in order to gain from both reductions. An extension of the model-checker {SPIN}, which implements this combination, is studied, showing substantial reduction over traditional search, not only in the number of reachable states, but directly in the amount of memory and time used.},
    author = {Peled, Doron},
    booktitle = {Computer Aided Verification},
    citeulike-article-id = {13095889},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/3-540-58179-0_69},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/3-540-58179-0_69},
    doi = {10.1007/3-540-58179-0_69},
    editor = {Dill, DavidL},
    keywords = {lsv, model-checking, partial-order-reductions},
    pages = {377--390},
    posted-at = {2014-03-06 22:45:21},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Combining partial order reductions with on-the-fly model-checking},
    url = {http://dx.doi.org/10.1007/3-540-58179-0_69},
    volume = {818},
    year = {1994}
}

@inproceedings{holzmann:ndfs,
    author = {Holzmann, Gerard J. and Peled, Doron and Yannakakis, Mihalis},
    booktitle = {Proc. Second SPIN Workshop},
    citeulike-article-id = {13095573},
    keywords = {holzmannndfs},
    pages = {81--89},
    posted-at = {2014-03-06 18:01:43},
    priority = {0},
    title = {On nested depth first search},
    volume = {32},
    year = {1996}
}

@inproceedings{vardi:memory,
    abstract = {{CiteSeerX} - Document Details (Isaac Councill, Lee Giles):},
    author = {Courcoubetis, C. and Vardi, M. and Wolper, P. and Yannakakis, M.},
    booktitle = {FORMAL METHODS IN SYSTEM DESIGN},
    citeulike-article-id = {13095570},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.139.2696},
    keywords = {lsv, model-checking, ndfs, verification},
    pages = {275--288},
    posted-at = {2014-03-06 17:58:13},
    priority = {0},
    title = {Memory-efficient algorithms for the verification of temporal properties},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.139.2696},
    year = {1992}
}

@inproceedings{gerth:otf,
    author = {Gerth, Rob and Peled, Doron and Vardi, Moshe Y. and Wolper, Pierre},
    booktitle = {Proceedings of the Fifteenth IFIP WG6. 1 International Symposium on Protocol Specification, Testing and Verification},
    citeulike-article-id = {13095512},
    keywords = {gerth-otf},
    organization = {IFIP},
    posted-at = {2014-03-06 16:41:28},
    priority = {0},
    title = {Simple on-the-fly automatic verification of linear temporal logic},
    year = {1995}
}

@article{holzmann:spin,
    abstract = {<{p><b>Abstract}</{b>—S}<{scp>PIN}</scp> is an efficient verification system for models of distributed software systems. It has been used to detect design errors in applications ranging from high-level descriptions of distributed algorithms to detailed code for controlling telephone exchanges. This paper gives an overview of the design and structure of the verifier, reviews its theoretical foundation, and gives an overview of significant practical applications.</p>},
    address = {Piscataway, NJ, USA},
    author = {Holzmann, Gerard J.},
    citeulike-article-id = {4190769},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=260902},
    citeulike-linkout-1 = {http://doi.ieeecomputersociety.org/10.1109/32.588521},
    citeulike-linkout-2 = {http://dx.doi.org/10.1109/32.588521},
    citeulike-linkout-3 = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=588521},
    day = {01},
    doi = {10.1109/32.588521},
    institution = {Comput. Sci. Res. Center, AT\&T Bell Labs., Murray Hill, NJ, USA},
    issn = {0098-5589},
    journal = {IEEE Transactions on Software Engineering},
    keywords = {lsv, model-checking, spin},
    month = may,
    number = {5},
    pages = {279--295},
    posted-at = {2014-03-06 16:28:58},
    priority = {0},
    publisher = {IEEE Computer Society},
    title = {The Model Checker {SPIN}},
    url = {http://dx.doi.org/10.1109/32.588521},
    volume = {23},
    year = {1997}
}

@inproceedings{vardi:reasoning,
    abstract = {We investigate extensions of temporal logic by connectives defined by finite automata on infinite words. We consider three different logics, corresponding to three different types of acceptance conditions (finite, looping and repeating) for the automata. It turns out, however, that these logics all have the same expressive power and that their decision problems are all {PSPACE}-complete. We also investigate connectives defined by alternating automata and show that they do not increase the expressive power of the logic or the complexity of the decision problem.  1 Introduction  For many years, logics of programs have been tools for reasoning about the input/output behavior of programs. When dealing with concurrent or nonterminating processes (like operating systems) there is, however, a need to reason about infinite computations. Thus, instead of considering the first and last states of finite computations, we need to consider the infinite sequences of states that the program goes through...},
    author = {Vardi, Moshe Y. and Wolper, Pierre},
    booktitle = {Information and Computation},
    citeulike-article-id = {11569645},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2841},
    keywords = {automata, lsv, model-checking},
    pages = {1--37},
    posted-at = {2014-03-06 16:28:06},
    priority = {0},
    title = {Reasoning about Infinite Computations},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2841},
    year = {1994}
}

@inproceedings{wadler:essence-fp,
    abstract = {This paper explores the use monads to structure functional
programs. No prior knowledge of monads or category theory is
required.

Monads increase the ease with which programs may be modified.
They can mimic the effect of impure features such as exceptions,
state, and continuations; and also provide effects not easily
achieved with such features. The types of a program reflect which
effects occur.

The first section is an extended example of the use of monads. A
simple interpreter is modified to support various extra features:
error messages, state, output, and non-deterministic choice. The
second section describes the relation between monads and the
continuation-passing style. The third section sketches how monads
are used in a compiler for Haskell that is written in Haskell.},
    address = {New York, NY, USA},
    author = {Wadler, Philip},
    booktitle = {Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
    citeulike-article-id = {1360},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=143169},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/143165.143169},
    doi = {10.1145/143165.143169},
    isbn = {0-89791-453-8},
    keywords = {functional, programming},
    location = {Albuquerque, New Mexico, USA},
    pages = {1--14},
    posted-at = {2014-02-20 21:52:03},
    priority = {0},
    publisher = {ACM},
    series = {POPL '92},
    title = {The Essence of Functional Programming},
    url = {http://dx.doi.org/10.1145/143165.143169},
    year = {1992}
}

@book{bertot:coq-2004,
    author = {Bertot, Yves and Cast{\'{e}}ran, Pierre},
    citeulike-article-id = {12904360},
    posted-at = {2014-01-09 18:22:22},
    priority = {1},
    publisher = {springer},
    title = {Interactive theorem proving and program development: {Coq'Art}: the calculus of inductive constructions},
    year = {2004}
}

@article{norell:agda-2007,
    abstract = {{CiteSeerX} - Document Details (Isaac Councill, Lee Giles):},
    author = {Norell, Ulf},
    citeulike-article-id = {12904358},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.65.7934},
    keywords = {agda, dependent-types, type-theory},
    posted-at = {2014-01-09 18:20:18},
    priority = {2},
    title = {Towards a practical programming language based on dependent type theory},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.65.7934},
    year = {2007}
}

@inproceedings{hancock:interactions-2000,
    abstract = {this paper we consider how to express specications of interactions in dependent type theory. The results so far are modest, though we hope we have identied some key structures for describing contracts between independent agents, and shown how to dene them in a dependently typed framework. These are called below transition systems (2.2) and interaction systems (2.3). Both are coalgebras; transition systems for a functor Fam , and interaction systems for its composite with itself, Fam (Fam ). These structures seems to have interesting connections with predicate transformer semantics for imperative programs, as initiated by Dijkstra, and also with the renement calculus of Back and von Wright as described in their book [2]. We restrict attention to situations in which the system and its environment communicate by exchanging messages in strict alternation, as with the moves in a two player game.},
    author = {Hancock, Peter and Setzer, Anton},
    booktitle = {In Workshop on subtyping and dependent types in programming},
    citeulike-article-id = {7867241},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.28.3720},
    keywords = {interaction-structure},
    posted-at = {2014-01-09 18:10:23},
    priority = {3},
    title = {Specifying Interactions With Dependent Types},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.28.3720},
    volume = {7},
    year = {2000}
}

@inbook{mcbride:epigram-2005,
    abstract = {Find the type error in the following Haskell expression: You can't, of course: this program is obviously nonsense unless you're a typechecker. The trouble is that only certain computations make sense if the null xs test is True, whilst others make sense if it is False. However, as far as the type system is concerned, the type of the then branch is the type of the else branch is the type of the entire conditional. Statically, the test is irrelevant. Which is odd, because if the test really were irrelevant, we wouldn't do it. Of course, doesn't go wrong—well-typed programs don't go wrong—so we'd better pick a different word for the way they do go. Abstraction and application, tupling and projection: these provide the 'software engineering' superstructure for programs, and our familiar type systems ensure that these operations are used compatibly. However, sooner or later, most programs inspect data and make a choice—at that point our familiar type systems fall silent. They simply can't talk about specific data. All this time, we thought our programming was strongly typed, when it was just our software engineering. In order to do better, we need a static language capable of expressing the significance of particular values in legitimizing some computations rather than others. We should not give up on programming.},
    address = {Berlin, Heidelberg},
    author = {McBride, Conor},
    chapter = {3},
    citeulike-article-id = {2247480},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/11546382_3},
    citeulike-linkout-1 = {http://www.springerlink.com/content/96j7v5vn8tyebeky},
    doi = {10.1007/11546382_3},
    editor = {Vene, Varmo and Uustalu, Tarmo},
    isbn = {978-3-540-28540-3},
    journal = {Advanced Functional Programming},
    keywords = {dependent, dependent-types, types},
    pages = {130--170},
    posted-at = {2014-01-09 18:07:00},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    title = {Epigram: Practical Programming with Dependent Types},
    url = {http://dx.doi.org/10.1007/11546382_3},
    volume = {3622},
    year = {2005}
}

@electronic{iso:finance,
    address = {http://www.iso20022.org/},
    author = {{UNIFI}},
    citeulike-article-id = {12810400},
    keywords = {finance, iso, protocol, standards},
    posted-at = {2013-12-02 21:07:54},
    priority = {1},
    title = {{ISO} 20022 {UNIversal} Financial Industry message scheme}
}

@article{girard:linear,
    abstract = {The familiar connective of negation is broken into two operations: linear negation which is the purely negative part of negation and the modality  ” of course” which has the meaning of a reaffirmation. Following this basic discovery, a completely new approach to the whole area between constructive logics and programmation is initiated.},
    address = {Essex, UK},
    author = {Girard, Jean-Yves},
    citeulike-article-id = {1334107},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=35356.35357},
    citeulike-linkout-1 = {http://dx.doi.org/10.1016/0304-3975(87)90045-4},
    citeulike-linkout-2 = {http://www.ams.org/mathscinet-getitem?mr=899269},
    doi = {10.1016/0304-3975(87)90045-4},
    issn = {03043975},
    journal = {Theoretical Computer Science},
    keywords = {linear, logic},
    month = jan,
    mrnumber = {MR899269},
    number = {1},
    pages = {1--101},
    posted-at = {2013-12-02 18:50:02},
    priority = {2},
    publisher = {Elsevier Science Publishers Ltd.},
    title = {Linear logic},
    url = {http://dx.doi.org/10.1016/0304-3975(87)90045-4},
    volume = {50},
    year = {1987}
}

@book{erlang,
    address = {http://citeseer.ist.psu.edu/393979.html},
    author = {Armstrong, Joe and Virding, Robert and Wikstr{\"o}m, Claes and Williams, Mike},
    citeulike-article-id = {1128874},
    keywords = {concurrency, embedded-systems},
    posted-at = {2013-12-02 18:11:53},
    priority = {2},
    publisher = {Prentice Hall},
    title = {Concurrent Programming in {ERLANG}},
    year = {1996}
}

@incollection{gay:sessiontypes,
    abstract = {We define an extension of the π-calculus with a static type system which supports high-level specifications of extended patterns of communication, such as client-server protocols. Subtyping allows protocol specifications to be extended in order to describe richer behaviour; an implemented server can then be replaced by a refined implementation, without invalidating type-correctness of the overall system. We use the {POP3} protocol as a concrete example of this technique.},
    author = {Gay, Simon and Hole, Malcolm},
    booktitle = {Programming Languages and Systems},
    citeulike-article-id = {4636703},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/3-540-49099-x_6},
    citeulike-linkout-1 = {http://www.springerlink.com/content/kbtj6c4kmrpgkfd0},
    citeulike-linkout-2 = {http://link.springer.com/chapter/10.1007/3-540-49099-X_6},
    doi = {10.1007/3-540-49099-x_6},
    editor = {Swierstra},
    journal = {Programming Languages and Systems},
    keywords = {session-types, subtype},
    pages = {74--90},
    posted-at = {2013-12-02 18:05:51},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Types and Subtypes for {Client-Server} Interactions},
    url = {http://dx.doi.org/10.1007/3-540-49099-x_6},
    volume = {1576},
    year = {1999}
}

@article{nanz:empirical,
    abstract = {Context: Developing concurrent software has long been recognized as a difficult and error-prone task. To support developers, a multitude of language proposals exist that promise to make concurrent programming easier. Empirical studies are needed to support the claim that a language is more usable than another. Objective: This paper presents the design of a study to compare concurrent programming languages with respect to comprehending and debugging existing programs and writing correct new programs. The design is applied to a comparison of two object-oriented languages for concurrency, multithreaded Java and {SCOOP}. Method: A critical challenge for such a study is avoiding the bias that might be introduced during the training phase and when interpreting participants' solutions. We address these issues by the use of self-study material and an evaluation scheme that exposes any subjective decisions of the corrector, or eliminates them altogether. Results: The study template consisting of the experimental design and the structure of the self-study and evaluation material is demonstrated to work successfully in an academic setting. The concrete instantiation of the study template shows results in favor of {SCOOP} even though the study participants had previous training in writing multithreaded Java programs. Conclusion: It is concluded that the proposed template of a small but therefore easy-to-implement empirical study with a focus on core language constructs is helpful in characterizing the usability of concurrent programming paradigms. Applying the template to further languages could shed light on which approaches are promising and hence drive language research into the right direction.},
    author = {Nanz, Sebastian and Torshizi, Faraz and Pedroni, Michela and Meyer, Bertrand},
    citeulike-article-id = {11211295},
    citeulike-linkout-0 = {http://dx.doi.org/10.1016/j.infsof.2012.08.013},
    doi = {10.1016/j.infsof.2012.08.013},
    issn = {09505849},
    journal = {Information and Software Technology},
    keywords = {empirical, languages, programming, usability},
    month = jul,
    number = {7},
    pages = {1304--1315},
    posted-at = {2013-12-02 13:47:46},
    priority = {0},
    title = {Design of an empirical study for comparing the usability of concurrent programming languages},
    url = {http://dx.doi.org/10.1016/j.infsof.2012.08.013},
    volume = {55},
    year = {2013}
}

@article{hoare:csp,
    abstract = {This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of a familiar programming exercises.},
    address = {New York, NY, USA},
    author = {Hoare, C. A. R.},
    citeulike-article-id = {785872},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=359585},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/359576.359585},
    doi = {10.1145/359576.359585},
    issn = {0001-0782},
    journal = {Commun. ACM},
    keywords = {communicating, processes, sequential},
    month = aug,
    number = {8},
    pages = {666--677},
    posted-at = {2013-12-02 12:10:41},
    priority = {2},
    publisher = {ACM},
    title = {Communicating Sequential Processes},
    url = {http://dx.doi.org/10.1145/359576.359585},
    volume = {21},
    year = {1978}
}

@article{atkey:parmonads,
    abstract = {Moggi's Computational Monads and Power et al.'s equivalent notion of Freyd category have captured a large range of computational effects present in programming languages. Examples include non-termination, non-determinism, exceptions, continuations, side effects and input/output. We present generalisations of both computational monads and Freyd categories, which we call parameterised monads and parameterised Freyd categories, that also capture computational effects with parameters. Examples of such are composable continuations, side effects where the type of the state varies and input/output where the range of inputs and outputs varies. By considering structured parameterisation also, we extend the range of effects to cover separated side effects and multiple independent streams of {I/O}. We also present two typed λ-calculi that soundly and completely model our categorical definitions – with and without symmetric monoidal parameterisation – and act as prototypical languages with parameterised effects.},
    author = {Atkey, Robert},
    citeulike-article-id = {12810058},
    citeulike-linkout-0 = {http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=5794688},
    citeulike-linkout-1 = {http://dx.doi.org/10.1017/s095679680900728x},
    doi = {10.1017/s095679680900728x},
    issn = {1469-7653},
    journal = {Journal of Functional Programming},
    keywords = {effects, monads, parameterised, state},
    month = jul,
    pages = {335--376},
    posted-at = {2013-12-02 11:29:42},
    priority = {4},
    title = {Parameterised notions of computation},
    url = {http://dx.doi.org/10.1017/s095679680900728x},
    volume = {19},
    year = {2009}
}

@book{milner:picalc,
    abstract = {{Communication is a fundamental and integral part of computing, whether between different computers on a network, or between components within a single computer. In this book Robin Milner introduces a new way of modelling communication that reflects its position. He treats computers and their programs as themselves built from communicating parts, rather than adding communication as an extra level of activity. Everything is introduced by means of examples, such as mobile phones, job schedualers, vending machines, data structures, and the objects of object-oriented programming. But the aim of the book is to develop a theory, the pi-calculus, in which these things can be treated rigorously.   The pi-calculus differs from other models of communicating behaviour mainly in its treatment of mobility. The movement of a piece of data inside a computer program is treated exactly the same as the transfer of a message--or indeed an entire computer program--across the internet. One can also describe networks which reconfigure themselves.  The calculus is very simple but powerful; its most prominent ingredient is the notion of a name. Its theory has two important ingredients: the concept of behavioural (or observational) equivalence, and the use of a new theory of types to classify patterns of interactive behaviour. The internet, and its communication protocols, fall within the scope of the theory just as much as computer programs, data structures, algorithms and programming languages.   This book is the first textbook on the subject; it has been long-awaited by professionals and will be welcome by them, and their students.}},
    author = {Milner, Robin},
    citeulike-article-id = {500640},
    citeulike-linkout-0 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20&amp;path=ASIN/0521658691},
    citeulike-linkout-1 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21&amp;path=ASIN/0521658691},
    citeulike-linkout-2 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21&amp;path=ASIN/0521658691},
    citeulike-linkout-3 = {http://www.amazon.jp/exec/obidos/ASIN/0521658691},
    citeulike-linkout-4 = {http://www.amazon.co.uk/exec/obidos/ASIN/0521658691/citeulike00-21},
    citeulike-linkout-5 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20&path=ASIN/0521658691},
    citeulike-linkout-6 = {http://www.worldcat.org/isbn/0521658691},
    citeulike-linkout-7 = {http://books.google.com/books?vid=ISBN0521658691},
    citeulike-linkout-8 = {http://www.amazon.com/gp/search?keywords=0521658691&index=books&linkCode=qs},
    citeulike-linkout-9 = {http://www.librarything.com/isbn/0521658691},
    day = {13},
    edition = {1st},
    howpublished = {Paperback},
    isbn = {0521658691},
    keywords = {calculus, process},
    month = jun,
    posted-at = {2013-12-02 00:11:15},
    priority = {2},
    publisher = {Cambridge University Press},
    title = {Communicating and Mobile Systems: The Pi Calculus},
    url = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20&path=ASIN/0521658691},
    year = {1999}
}

@book{milner:ccs,
    abstract = {An abstract is not available.},
    address = {Secaucus, NJ, USA},
    author = {Milner, R.},
    citeulike-article-id = {3055332},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=539036},
    isbn = {0387102353},
    keywords = {calculus, calculusbisimulationprocess},
    posted-at = {2013-12-02 00:10:33},
    priority = {2},
    publisher = {Springer-Verlag New York, Inc.},
    title = {A Calculus of Communicating Systems},
    url = {http://portal.acm.org/citation.cfm?id=539036},
    year = {1982}
}

@article{denielou:multirole-sessions,
    abstract = {Multiparty session types enforce structured safe communications between several participants, as long as their number is fixed when the session starts. In order to handle common distributed interaction patterns such as peer-to-peer protocols or cloud algorithms, we propose a new role-based multiparty session type theory where roles are defined as classes of local behaviours that an arbitrary number of participants can dynamically join and leave. We offer programmers a polling operation that gives access to the current set of a role's participants in order to fork processes. Our type system with universal types for polling can handle this dynamism and retain type safety. A multiparty locking mechanism is introduced to provide communication safety, but also to ensure a stronger progress property for joining participants that has never been guaranteed in previous systems. Finally, we present some implementation mechanisms used in our prototype extension of {ML}.},
    address = {New York, NY, USA},
    author = {Deni{\'{e}}lou, Pierre M. and Yoshida, Nobuko},
    citeulike-article-id = {12807484},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1926435},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1925844.1926435},
    doi = {10.1145/1925844.1926435},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {implementation, session-types},
    month = jan,
    number = {1},
    pages = {435--446},
    posted-at = {2013-12-01 21:12:54},
    priority = {3},
    publisher = {ACM},
    title = {Dynamic Multirole Session Types},
    url = {http://dx.doi.org/10.1145/1925844.1926435},
    volume = {46},
    year = {2011}
}

@article{gay:linearsessions,
    abstract = {Session types support a type-theoretic formulation of structured patterns of communication, so that the communication behaviour of agents in a distributed system can be verified by static typechecking. Applications include network protocols, business processes and operating system services. In this paper we define a multithreaded functional language with session types, which unifies, simplifies and extends previous work. There are four main contributions. First is an operational semantics with buffered channels, instead of the synchronous communication of previous work. Second, we prove that the session type of a channel gives an upper bound on the necessary size of the buffer. Third, session types are manipulated by means of the standard structures of a linear type theory, rather than by means of new forms of typing judgement. Fourth, a notion of subtyping, including the standard subtyping relation for session types (imported into the functional setting), and a novel form of subtyping between standard and linear function types, which allows the typechecker to handle linear types conveniently. Our new approach significantly simplifies session types in the functional setting, clarifies their essential features and provides a secure foundation for language developments such as polymorphism and object-orientation.},
    author = {Gay, Simon J. and Vasconcelos, Vasco T.},
    citeulike-article-id = {6552457},
    citeulike-linkout-0 = {http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=6821608},
    citeulike-linkout-1 = {http://dx.doi.org/10.1017/s0956796809990268},
    doi = {10.1017/s0956796809990268},
    issn = {1469-7653},
    journal = {Journal of Functional Programming},
    keywords = {linear, logic, session-types},
    month = jan,
    pages = {19--50},
    posted-at = {2013-12-01 21:03:28},
    priority = {0},
    title = {Linear type theory for asynchronous session types},
    url = {http://dx.doi.org/10.1017/s0956796809990268},
    volume = {20},
    year = {2010}
}

@incollection{neubauer:implementation2004,
    abstract = {A session type is an abstraction of a set of sequences of heterogeneous values sent and received over a communication channel. Session types can be used for specifying stream-based Internet protocols.
                          Typically, session types are attached to communication-based program calculi, which renders them theoretical tools which are not readily usable in practice. To transfer session types into practice, we propose an embedding of a core calculus with session types into the functional programming language Haskell. The embedding preserves typing. A case study (a client for {SMTP}, the Simple Mail Transfer Protocol) demonstrates the feasibility of our approach.},
    author = {Neubauer, Matthias and Thiemann, Peter},
    booktitle = {Practical Aspects of Declarative Languages},
    citeulike-article-id = {12807480},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-540-24836-1_5},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-540-24836-1_5},
    doi = {10.1007/978-3-540-24836-1_5},
    editor = {Jayaraman, Bharat},
    keywords = {haskell, implementation, session-types},
    pages = {56--70},
    posted-at = {2013-12-01 21:02:31},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {An Implementation of Session Types},
    url = {http://dx.doi.org/10.1007/978-3-540-24836-1_5},
    volume = {3057},
    year = {2004}
}

@incollection{honda:primitives,
    abstract = {We introduce basic language constructs and a type discipline as a foundation of structured communication-based concurrent programming. The constructs, which are easily translatable into the summation-less asynchronous π-calculus, allow programmers to organise programs as a combination of multiple flows of (possibly unbounded) reciprocal interactions in a simple and elegant way, subsuming the preceding communication primitives such as method invocation and rendez-vous. The resulting syntactic structure is exploited by a type discipline \`{a} la {ML}, which offers a high-level type abstraction of interactive behaviours of programs as well as guaranteeing the compatibility of interaction patterns between processes in a well-typed program. After presenting the formal semantics, the use of language constructs is illustrated through examples, and the basic syntactic results of the type discipline are established. Implementation concerns are also addressed.},
    address = {Berlin/Heidelberg},
    author = {Honda, Kohei and Vasconcelos, Vasco T. and Kubo, Makoto},
    booktitle = {Programming Languages and Systems},
    chapter = {9},
    citeulike-article-id = {2633817},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/bfb0053567},
    citeulike-linkout-1 = {http://www.springerlink.com/content/c7m30x8863j6w3pm},
    citeulike-linkout-2 = {http://link.springer.com/chapter/10.1007/BFb0053567},
    doi = {10.1007/bfb0053567},
    editor = {Hankin, Chris},
    isbn = {3-540-64302-8},
    journal = {Programming Languages and Systems},
    keywords = {session-types},
    pages = {122--138},
    posted-at = {2013-12-01 20:59:58},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Language primitives and type discipline for structured communication-based programming},
    url = {http://dx.doi.org/10.1007/bfb0053567},
    volume = {1381},
    year = {1998}
}

@incollection{honda:interaction1994,
    abstract = {We present a small language 
                              
                              
              \$\mathcal{L}\$
              
                             and its typing system, starting from the idea of interaction, one of the important notions in parallel and distributed computing. 
                              
                              
              \$\mathcal{L}\$
              
                             is based on, apart from such constructs as parallel composition and process creation, three pairs of communication primitives which use the notion of a session, a semantically atomic chain of communication actions which can interleave with other such chains freely, for high-level abstraction of interactionbased computing. The three primitives enable programmers to elegantly describe complex interactions among processes with a rigorous type discipline similar to ML [4]. The language is given formal operational semantics and a type inference system, regarding which we prove that if a program is well-typed in the typing system, it never causes run-time error due to type inconsistent communication patterns, offering a new foundation for type discipline in parallel programming languages.},
    author = {Takeuchi, Kaku and Honda, Kohei and Kubo, Makoto},
    booktitle = {PARLE'94 Parallel Architectures and Languages Europe},
    citeulike-article-id = {1100085},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/3-540-58184-7_118},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/3-540-58184-7_118},
    doi = {10.1007/3-540-58184-7_118},
    editor = {Halatsis, Costas and Maritsas, Dimitrios and Philokyprou, George and Theodoridis, Sergios},
    journal = {: PARLE'94 Parallel Architectures and Languages Europe},
    keywords = {session-types},
    pages = {398--413},
    posted-at = {2013-12-01 20:58:31},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {An interaction-based language and its typing system},
    url = {http://dx.doi.org/10.1007/3-540-58184-7_118},
    volume = {817},
    year = {1994}
}

@incollection{dezani:survey,
    abstract = {We illustrate the concepts of sessions and session types as they have been developed in the setting of the π-calculus. Motivated by the goal of obtaining a formalisation closer to existing standards and aiming at their enhancement and strengthening, several extensions of the original core system have been proposed, which we survey together with the embodying of sessions into functional and object-oriented languages, as well as some implementations.},
    author = {Dezani-Ciancaglini, Mariangiola and de'Liguoro, Ugo},
    booktitle = {Web Services and Formal Methods},
    citeulike-article-id = {12807468},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-14458-5_1},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-14458-5_1},
    doi = {10.1007/978-3-642-14458-5_1},
    editor = {Laneve, Cosimo and Su, Jianwen},
    keywords = {services, session-types, survey, web},
    pages = {1--28},
    posted-at = {2013-12-01 20:57:03},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Sessions and Session Types: An Overview},
    url = {http://dx.doi.org/10.1007/978-3-642-14458-5_1},
    volume = {6194},
    year = {2010}
}

@inproceedings{fahndrich:singularity,
    abstract = {Message-based communication offers the potential benefits of providing stronger specification and cleaner separation between components. Compared with shared-memory interactions, message passing has the potential disadvantages of more expensive data exchange (no direct sharing) and more complicated {programming.In} this paper we report on the language, verification, and run-time system features that make messages practical as the sole means of communication between processes in the Singularity operating system. We show that using advanced programming language and verification techniques, it is possible to provide and enforce strong system-wide invariants that enable efficient communication and low-overhead software-based process isolation. Furthermore, specifications on communication channels help in detecting programmer mistakes early---namely at compile-time---thereby reducing the difficulty of the message-based programming {model.The} paper describes our communication invariants, the language and verification features that support them, as well as implementation details of the infrastructure. A number of benchmarks show the competitiveness of this approach.},
    address = {New York, NY, USA},
    author = {F\"{a}hndrich, Manuel and Aiken, Mark and Hawblitzel, Chris and Hodson, Orion and Hunt, Galen and Larus, James R. and Levi, Steven},
    booktitle = {Proceedings of the 1st ACM SIGOPS/EuroSys European Conference on Computer Systems 2006},
    citeulike-article-id = {9333470},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1217953},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1217935.1217953},
    doi = {10.1145/1217935.1217953},
    isbn = {1-59593-322-0},
    keywords = {operating-systems, session-types},
    location = {Leuven, Belgium},
    pages = {177--190},
    posted-at = {2013-12-01 20:54:59},
    priority = {0},
    publisher = {ACM},
    series = {EuroSys '06},
    title = {Language Support for Fast and Reliable Message-based Communication in Singularity {OS}},
    url = {http://dx.doi.org/10.1145/1217935.1217953},
    year = {2006}
}

@article{pucella:session-haskell2008,
    abstract = {We describe an implementation of session types in Haskell. Session types statically enforce that client-server communication proceeds according to protocols. They have been added to several concurrent calculi, but few implementations of session types are available. Our embedding takes advantage of Haskell where appropriate, but we rely on no exotic features. Thus our approach translates with minimal modification to other polymorphic, typed languages such as {ML} and Java. Our implementation works with existing Haskell concurrency mechanisms, handles multiple communication channels and recursive session types, and infers protocols automatically. While our implementation uses unsafe operations in Haskell, it does not violate Haskell's safety guarantees. We formalize this claim in a concurrent calculus with unsafe communication primitives over which we layer our implementation of session types, and we prove that the session types layer is safe. In particular, it enforces that channel-based communication follows consistent protocols.},
    address = {New York, NY, USA},
    author = {Pucella, Riccardo and Tov, Jesse A.},
    citeulike-article-id = {12807466},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1411290},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1543134.1411290},
    doi = {10.1145/1543134.1411290},
    issn = {0362-1340},
    journal = {SIGPLAN Not.},
    keywords = {haskell, session-types},
    month = sep,
    number = {2},
    pages = {25--36},
    posted-at = {2013-12-01 20:53:51},
    priority = {0},
    publisher = {ACM},
    title = {Haskell Session Types with (Almost) No Class},
    url = {http://dx.doi.org/10.1145/1543134.1411290},
    volume = {44},
    year = {2008}
}

@article{sackman:haskell-session2008,
    author = {Sackman, Matthew and Eisenbach, Susan},
    citeulike-article-id = {12807465},
    keywords = {haskell, implementation, session-types},
    posted-at = {2013-12-01 20:52:54},
    priority = {0},
    title = {Session Types in Haskell},
    year = {2008}
}

@techreport{caires:relational2012,
    author = {Caires, Lu{\i}s and P{\'{e}}rez, Jorge A. and Pfenning, Frank and Toninho, Bernardo},
    citeulike-article-id = {12807463},
    institution = {Tech. Rep. CMU-CS-12-108, Carnegie Mellon Univ},
    keywords = {linear, logic, parametricity, relational, session-types},
    posted-at = {2013-12-01 20:47:40},
    priority = {1},
    title = {Relational parametricity for polymorphic session types},
    year = {2012}
}

@inproceedings{cooper:links2006,
    abstract = {Links is a programming language for web applications that generates code for all three tiers of a web application from a single source, compiling into {JavaScript} to run on the client and into {SQL} to run on the database. Links supports rich clients running in what has been dubbed 'Ajax' style, and supports concurrent processes with statically-typed message passing. Links is scalable in the sense that session state is preserved in the client rather than the server, in contrast to other approaches such as Java Servlets or {PLT} Scheme. Client-side concurrency in {JavaScript} and transfer of computation between client and server are both supported by translation into continuation-passing style.},
    author = {Cooper, Ezra and Lindley, Sam and Wadler, Philip and Yallop, Jeremy},
    booktitle = {Formal Methods for Components and Objects},
    citeulike-article-id = {12807461},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-540-74792-5_12},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-540-74792-5_12},
    doi = {10.1007/978-3-540-74792-5_12},
    editor = {de Boer, Frank S. and Bonsangue, Marcello M. and Graf, Susanne and de Roever, Willem-Paul},
    keywords = {links, programming, web},
    pages = {266--296},
    posted-at = {2013-12-01 20:42:59},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {FMCO '06},
    title = {{Links: Web Programming Without Tiers}},
    url = {http://dx.doi.org/10.1007/978-3-540-74792-5_12},
    volume = {4709},
    year = {2007}
}

@incollection{caires:logic,
    abstract = {Several type disciplines for π-calculi have been proposed in which linearity plays a key role, even if their precise relationship with pure linear logic is still not well understood. In this paper, we introduce a type system for the π-calculus that exactly corresponds to the standard sequent calculus proof system for dual intuitionistic linear logic. Our type system is based on a new interpretation of linear propositions as session types, and provides the first purely logical account of all (both shared and linear) features of session types. We show that our type discipline is useful from a programming perspective, and ensures session fidelity, absence of deadlocks, and a tight operational correspondence between π-calculus reductions and cut elimination steps.},
    author = {Caires, Lu\'{\i}s and Pfenning, Frank},
    booktitle = {CONCUR 2010 - Concurrency Theory},
    citeulike-article-id = {12807458},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-15375-4_16},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-15375-4_16},
    doi = {10.1007/978-3-642-15375-4_16},
    editor = {Gastin, Paul and Laroussinie, Fran\c{c}ois},
    keywords = {linear, logic, session-types},
    pages = {222--236},
    posted-at = {2013-12-01 20:41:10},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Session Types as Intuitionistic Linear Propositions},
    url = {http://dx.doi.org/10.1007/978-3-642-15375-4_16},
    volume = {6269},
    year = {2010}
}

@incollection{honda:dyadic,
    abstract = {We formulate a typed formalism for concurrency where types denote freely composable structure of dyadic interaction in the symmetric scheme. The resulting calculus is a typed reconstruction of name passing process calculi. Systems with both the explicit and implicit typing disciplines, where types form a simple hierarchy of types, are presented, which are proved to be in accordance with each other. A typed variant of bisimilarity is formulated and it is shown that typed β-equality has a clean embedding in the bisimilarity. Name reference structure induced by the simple hierarchy of types is studied, which fully characterises the typable terms in the set of untyped terms. It turns out that the name reference structure results in the deadlock-free property for a subset of terms with a certain regular structure, showing behavioural significance of the simple type discipline.},
    author = {Honda, Kohei},
    booktitle = {CONCUR'93},
    citeulike-article-id = {12807457},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/3-540-57208-2_35},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/3-540-57208-2_35},
    doi = {10.1007/3-540-57208-2_35},
    editor = {Best, Eike},
    keywords = {session-types},
    pages = {509--523},
    posted-at = {2013-12-01 20:38:24},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Types for dyadic interaction},
    url = {http://dx.doi.org/10.1007/3-540-57208-2_35},
    volume = {715},
    year = {1993}
}

@inbook{honda:scribble,
    abstract = {In this paper we discuss our ongoing endeavour to apply notations and algorithms based on the π-calculus and its theories for the development of large-scale distributed systems. The execution of a large-scale distributed system consists of many structured conversations (or sessions) whose protocols can be clearly and accurately specified using a theory of types for the π-calculus, called session types. The proposed methodology promotes a formally founded, and highly structured, development framework for modelling and building distributed applications, from high-level models to design and implementation to static checking to runtime validation. At the centre of this methodology is a formal description language for representing protocols for interactions, called Scribble. We illustrate the usage and theoretical basis of this language through use cases from different application domains.},
    address = {Berlin, Heidelberg},
    author = {Honda, Kohei and Mukhamedov, Aybek and Brown, Gary and Chen, Tzu-Chun and Yoshida, Nobuko},
    booktitle = {Distributed Computing and Internet Technology},
    chapter = {4},
    citeulike-article-id = {12807456},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-19056-8_4},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-19056-8_4},
    doi = {10.1007/978-3-642-19056-8_4},
    editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Natarajan, Raja and Ojo, Adegboyega},
    isbn = {978-3-642-19055-1},
    issn = {1611-3349},
    keywords = {scribble, session-types},
    pages = {55--75},
    posted-at = {2013-12-01 20:37:31},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Scribbling Interactions with a Formal Foundation},
    url = {http://dx.doi.org/10.1007/978-3-642-19056-8_4},
    volume = {6536},
    year = {2011}
}

@article{neykova:dynamic,
    author = {Neykova, Rumyana},
    citeulike-article-id = {12807455},
    journal = {PLACES 2013},
    keywords = {dynamic, session-types},
    pages = {34},
    posted-at = {2013-12-01 20:36:23},
    priority = {0},
    title = {Session {T}ypes {G}o {D}ynamic or {H}ow to {V}erify {Y}our {P}ython {C}onversations},
    year = {2013}
}

@incollection{carbone:exceptions,
    abstract = {We propose an interactional generalisation of structured exceptions based on the session type discipline. Interactional exceptions allow communicating peers to asynchronously and collaboratively escape from the middle of a dialogue and reach another in a coordinated fashion, under an arbitrary nesting of exceptions. New exception types guarantee communication safety and offer a precise type-abstraction of advanced conversation patterns found in practice. Protocols for coordinating normal and exceptional exit among asynchronously running sessions are introduced. The liveness property established under these protocols guarantees consistency of coordinated exception handling among communicating peers.},
    author = {Carbone, Marco and Honda, Kohei and Yoshida, Nobuko},
    booktitle = {CONCUR 2008 - Concurrency Theory},
    citeulike-article-id = {12807454},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-540-85361-9_32},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-540-85361-9_32},
    doi = {10.1007/978-3-540-85361-9_32},
    editor = {Breugel, Franck and Chechik, Marsha},
    keywords = {exceptions, session-types},
    pages = {402--417},
    posted-at = {2013-12-01 20:34:46},
    priority = {0},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {Structured Interactional Exceptions in Session Types},
    url = {http://dx.doi.org/10.1007/978-3-540-85361-9_32},
    volume = {5201},
    year = {2008}
}

@inproceedings{mandelbaum:padsml-popl07,
    abstract = {Massive amounts of useful data are stored and processed in ad hoc formats for which common tools like parsers, printers, query engines and format converters are not readily available. In this paper, we explain the design and implementation of {PADS}/{ML} , a new language and system that facilitates the generation of data processing tools for ad hoc formats. The {PADS}/{ML} design includes features such as dependent, polymorphic and recursive datatypes, which allow programmers to describe the syntax and semantics of ad hoc data in a concise, easy-to-read notation. The {PADS}/{ML} implementation compiles these descriptions into ml structures and functors that include types for parsed data, functions for parsing and printing, and auxiliary support for user-specified, format-dependent and format-independent tool generation.},
    address = {New York, NY, USA},
    author = {Mandelbaum, Yitzhak and Fisher, Kathleen and Walker, David and Fernandez, Mary and Gleyzer, Artem},
    booktitle = {Proceedings of the 34th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
    citeulike-article-id = {3682579},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1190216.1190231},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1190216.1190231},
    doi = {10.1145/1190216.1190231},
    isbn = {1-59593-575-4},
    keywords = {ddl, functional, pads, programming},
    location = {Nice, France},
    pages = {77--83},
    posted-at = {2013-09-23 17:18:27},
    priority = {2},
    publisher = {ACM},
    series = {POPL '07},
    title = {{PADS}/{ML}: a functional data description language},
    url = {http://dx.doi.org/10.1145/1190216.1190231},
    year = {2007}
}

@inproceedings{fisher:pads-pldi06,
    abstract = {{PADS} is a declarative data description language that allows data analysts to describe both the physical layout of ad hoc data sources and semantic properties of that data. From such descriptions, the {PADS} compiler generates libraries and tools for manipulating the data, including parsing routines, statistical profiling tools, translation programs to produce well-behaved formats such as Xml or those required for loading relational databases, and tools for running {XQueries} over raw {PADS} data sources. The descriptions are concise enough to serve as "living" documentation while flexible enough to describe most of the {ASCII}, binary, and Cobol formats that we have seen in practice. The generated parsing library provides for robust, application-specific error handling.},
    address = {New York, NY, USA},
    author = {Fisher, Kathleen and Gruber, Robert},
    booktitle = {Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation},
    citeulike-article-id = {681676},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1065046},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1065010.1065046},
    doi = {10.1145/1065010.1065046},
    isbn = {1-59593-056-6},
    issn = {0362-1340},
    keywords = {ddl, pads},
    location = {Chicago, IL, USA},
    month = jun,
    number = {6},
    pages = {295--304},
    posted-at = {2013-09-23 17:15:45},
    priority = {3},
    publisher = {ACM},
    series = {PLDI '05},
    title = {{PADS}: A Domain-specific Language for Processing Ad Hoc Data},
    url = {http://dx.doi.org/10.1145/1065010.1065046},
    volume = {40},
    year = {2005}
}

@incollection{wang:processingdata-ifl11,
    abstract = {Ad hoc data formats, i.e. semistructured non-standard data formats, are pervasive in many domains that need software tools — bioinformatics, demographic surveys, geophysics and network software are just a few. Building tools becomes easier if parsing and other standard input-output processing can be automated. Modern approaches for dealing with ad hoc data formats consist of domain specific languages based on type systems. Compilers for these languages generate data structures and parsing functions in a target programming language in which tools and applications are then written. We present a monadic library in Haskell that implements a data description language. Using our library, Haskell programmers have access to data description primitives that can be used for parsing and that can be integrated with other libraries and application programs without the need of yet another compiler.},
    author = {Wang, Yan and Gaspes, Ver\'{o}nica},
    booktitle = {Implementation and Application of Functional Languages},
    citeulike-article-id = {12642836},
    citeulike-linkout-0 = {http://dx.doi.org/10.1007/978-3-642-24452-0_10},
    citeulike-linkout-1 = {http://link.springer.com/chapter/10.1007/978-3-642-24452-0_10},
    doi = {10.1007/978-3-642-24452-0_10},
    editor = {Scholz, Sven-Bodo and Chitil, Olaf},
    keywords = {data, dsl, embedded, haskell, monadic, parsing},
    pages = {174--191},
    posted-at = {2013-09-23 16:28:11},
    priority = {2},
    publisher = {Springer Berlin Heidelberg},
    series = {Lecture Notes in Computer Science},
    title = {A Library for Processing Ad hoc Data in Haskell},
    url = {http://dx.doi.org/10.1007/978-3-642-24452-0_10},
    volume = {5836},
    year = {2011}
}

@inproceedings{wang:protege,
    abstract = {Protocol stack specifications are well-structured documents that follow a number of conventions and notations that have proven very useful for the design and dissemination of communication protocols. Protocol stack implementations on the other hand, are done in low-level languages, using error-prone programming techniques resulting in programs that are difficult to relate to the specifications, difficult to maintain, modify, extend and reuse. To overcome these problems we propose a domain-specific language that provides abstractions close to the notations used in protocol specifications. From descriptions in our language we generate C programs that can be integrated with other systems software. The language provides constructs to describe packet formats, including physical layout, constraints and dependencies. It also provides constructs for state machines and for layering protocols into stacks. Experiments show that the C programs we generate are comparable in performance and binary size to hand-crafted C programs.},
    address = {New York, NY, USA},
    author = {Wang, Yan and Gaspes, Ver\'{o}nica},
    booktitle = {Proceedings of the 20th ACM SIGPLAN workshop on Partial evaluation and program manipulation},
    citeulike-article-id = {12642829},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1929511},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1929501.1929511},
    doi = {10.1145/1929501.1929511},
    isbn = {978-1-4503-0485-6},
    keywords = {domain, dsl, embedded, language, networking, protocol, specific, systems},
    location = {Austin, Texas, USA},
    pages = {63--72},
    posted-at = {2013-09-23 16:26:11},
    priority = {2},
    publisher = {ACM},
    series = {PEPM '11},
    title = {An embedded language for programming protocol stacks in embedded systems},
    url = {http://dx.doi.org/10.1145/1929501.1929511},
    year = {2011}
}

@inproceedings{back:datascript-gpce02,
    abstract = {Abstract. {DataScript} is a language to describe and manipulate binary data formats as types. {DataScript} consists of two components: a constraint-based specification language that uses {DataScript} types to describe the physical layout of data and a language binding that provides a simple programming interface to script binary data. A {DataScript} compiler generates Java libraries that are linked with {DataScript} scripts. {DataScript} specifications can be used to describe formats in a programmatic way, eliminating the vagaries and ambiguities often associated with prosaic format descriptions. The libraries generated by the {DataScript} compiler free the programmer from the tedious task of coding input and output routines. More importantly, they assure correctness and safety by validating both the input read and the output generated. We show examples that demonstrate that {DataScript} is simple, yet powerful enough to describe many commonly used formats. Similar to how scripting languages such as Perl allow the manipulation of text files, the libraries generated by the {DataScript} compiler can be used to quickly write scripts that safely manipulate binary files. 1},
    author = {Back, Godmar},
    booktitle = {In Generative Programming and Component Engineering},
    citeulike-article-id = {12642801},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.140.2378},
    keywords = {amhiahe, data, defomotopm},
    pages = {66--77},
    posted-at = {2013-09-23 16:16:19},
    priority = {3},
    title = {{DataScript} - A Specification and Scripting Language for Binary Data},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.140.2378},
    year = {2002}
}

@inproceedings{vandenbos:ddlforensics-icse11,
    abstract = {Digital forensics investigations often consist of analyzing large quantities of data. The software tools used for analyzing such data are constantly evolving to cope with a multiplicity of versions and variants of data formats. This process of customization is time consuming and error prone. To improve this situation we present Derric, a domain-specific language ({DSL}) for declaratively specifying data structures. This way, the specification of structure is separated from data processing. The resulting architecture encourages customization and facilitates reuse. It enables faster development through a division of labour between investigators and software engineers. We have performed an initial evaluation of Derric by constructing a data recovery tool. This so-called carver has been automatically derived from a declarative description of the structure of {JPEG} files. We compare it to existing carvers, and show it to be in the same league both with respect to recovered evidence, and runtime performance.},
    address = {New York, NY, USA},
    author = {van den Bos, Jeroen and van der Storm, Tijs},
    booktitle = {Proceedings of the 33rd International Conference on Software Engineering},
    citeulike-article-id = {12642789},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1985887},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1985793.1985887},
    doi = {10.1145/1985793.1985887},
    isbn = {978-1-4503-0445-0},
    keywords = {big, data, ddl, domain, dsl, language, specific},
    location = {Waikiki, Honolulu, HI, USA},
    pages = {671--680},
    posted-at = {2013-09-23 16:14:22},
    priority = {2},
    publisher = {ACM},
    series = {ICSE '11},
    title = {Bringing domain-specific languages to digital forensics},
    url = {http://dx.doi.org/10.1145/1985793.1985887},
    year = {2011}
}

@inproceedings{fisher:700ddl,
    abstract = {In the spirit of Landin, we present a calculus of dependent types to serve as the semantic foundation for a family of languages called  data description languages . Such languages, which include  pads ,  datascript , and  packettypes , are designed to facilitate programming with  ad hoc data, ie , data not in well-behaved relational or  xml  formats. In the calculus, each type describes the physical layout and semantic properties of a data source. In the semantics, we interpret types simultaneously as the in-memory representation of the data described and as parsers for the data source. The parsing functions are robust, automatically detecting and recording errors in the data stream without halting parsing. We show the parsers are type-correct, returning data whose type matches the simple-type interpretation of the specification. We also prove the parsers are "error-correct," accurately reporting the number of physical and semantic errors that occur in the returned data. We use the calculus to describe the features of various data description languages, and we discuss how we have used the calculus to improve  {PADS} .},
    address = {New York, NY, USA},
    author = {Fisher, Kathleen and Mandelbaum, Yitzhak and Walker, David},
    booktitle = {POPL '06: Conference record of the 33rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
    citeulike-article-id = {5453708},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1111037.1111039},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1111037.1111039},
    doi = {10.1145/1111037.1111039},
    isbn = {1-59593-027-2},
    keywords = {data, definition, dependent, language, types},
    location = {Charleston, South Carolina, USA},
    pages = {2--15},
    posted-at = {2013-09-23 16:12:12},
    priority = {3},
    publisher = {ACM},
    title = {The next 700 data description languages},
    url = {http://dx.doi.org/10.1145/1111037.1111039},
    year = {2006}
}

@inproceedings{mccann:packettypes,
    abstract = {In writing networking code, one is often faced with the task of interpreting a raw buffer according to a standardized packet format. This is needed, for example, when monitoring network traffic for specific kinds of packets, or when unmarshaling an incoming packet for protocol processing. In such cases, a programmer typically writes C code that understands the grammar of a packet and that also performs any necessary byte-order and alignment adjustments. Because of the complexity of certain protocol formats, and because of the low-level of programming involved, writing such code is usually a cumbersome and error-prone process. Furthermore, code written in this style loses the domain-specific information, viz. the packet format, in its details, making it difficult to maintain.},
    address = {New York, NY, USA},
    author = {McCann, Peter J. and Chandra, Satish},
    booktitle = {Proceedings of the conference on Applications, Technologies, Architectures, and Protocols for Computer Communication},
    citeulike-article-id = {1291010},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=347563},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/347059.347563},
    doi = {10.1145/347059.347563},
    isbn = {1-58113-223-9},
    issn = {0146-4833},
    keywords = {domain, network, packet, packettypes, parse, specific, types},
    location = {Stockholm, Sweden},
    pages = {321--333},
    posted-at = {2013-09-23 14:20:46},
    priority = {5},
    publisher = {ACM},
    series = {SIGCOMM '00},
    title = {Packet types: abstract specification of network protocol messages},
    url = {http://dx.doi.org/10.1145/347059.347563},
    year = {2000}
}

@incollection{coutts:bytestrings-padl07,
    abstract = {The Haskell String type is notoriously inefficient. We introduce a new data type, {ByteString}, based on lazy lists of byte arrays, combining the speed benefits of strict arrays with lazy evaluation. Equational transformations based on term rewriting are used to deforest intermediate {ByteStrings} automatically. We describe novel fusion combinators with improved expressiveness and performance over previous functional array fusion strategies. A library for {ByteStrings} is implemented, providing a purely functional interface, which approaches the speed of low-level mutable arrays in C.},
    author = {Coutts, Duncan and Stewart, Don and Leshchinskiy, Roman},
    citeulike-article-id = {2386786},
    citeulike-linkout-0 = {http://www.cse.unsw.edu.au/~dons/papers/CSL06.html},
    citeulike-linkout-1 = {http://dx.doi.org/10.1007/978-3-540-69611-7_3},
    doi = {10.1007/978-3-540-69611-7_3},
    journal = {Practical Aspects of Declarative Languages},
    keywords = {deforestation, fusion, haskell, performance, rewriting, streams, strings},
    pages = {50--64},
    posted-at = {2013-09-17 15:49:42},
    priority = {3},
    title = {Rewriting Haskell Strings},
    url = {http://www.cse.unsw.edu.au/~dons/papers/CSL06.html},
    year = {2007}
}

@article{bhatti:dsls-ngna09,
    abstract = {Next generation network architectures will benefit from the many years of practical experience that have been gained in designing, using and operating network protocols. Over time, the networking community has gradually improved its understanding of networked systems in terms of architecture, design, engineering and testing. However, as protocols and networked systems become more complex, it is our contention that it will be necessary for programming techniques to evolve similarly so that they better support the design, implementation and testing of both the functional and the non-functional requirements for the network protocols that will be used. We therefore envisage new levels of programming language support that permit: (a) the design and implementation of new protocols with provably correct construction; (b) inline testing; and (c) the expression of protocol behaviour within the design. Based on our ongoing work with both network protocols and programming language design, we believe that exploiting the capabilities of recent work in Domain Specific Languages ({DSLs}) will allow us to meet such requirements, allowing straightforward and \^{a}correctby-construction\^{a} design and implementation of next generation network protocols. 1.},
    author = {Bhatti, Saleem and Brady, Edwin and Hammond, Kevin and Mckinna, James},
    citeulike-article-id = {12629041},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.150.1113},
    keywords = {dependent, domain, idris, languages, network, protocols, specific, types},
    posted-at = {2013-09-16 19:10:38},
    priority = {0},
    title = {Domain Specific Languages ({DSLs}) for Network Protocols (Position Paper)},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.150.1113}
}

@proceedings{wadler:imperative,
    abstract = {We present a new model, based on monads, for performing input/output in a non-strict, purely functional language. It is composable, extensible, efficient, requires no extensions to the type system, and extends smoothly to incorporate mixed-language working and in-place array updates. 1 Introduction Input/output has always appeared to be one of the less satisfactory features of purely functional languages: fitting action into the functional paradigm feels like fitting a square block into a round ...},
    author = {Simon, S. L. P. and Wadler, Philip},
    booktitle = {Conference record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Charleston, South Carolina},
    citeulike-article-id = {1214},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.2504},
    keywords = {functional, imperative, monad},
    pages = {71--84},
    posted-at = {2013-09-16 18:53:09},
    priority = {2},
    title = {Imperative Functional Programming},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.2504},
    year = {1993}
}

@book{spj:haskell,
    abstract = {{Haskell is the world's leading lazy functional programming language and is widely used in teaching, research, and applications.  The language continues to develop rapidly, but in 1998 the programming community decided to capture a stable snapshot of the language by introducing Haskell 98. This book constitutes the agreed definition of Haskell 98, the language itself as well as its supporting libraries, and should be a standard reference work for anyone involved in research, teaching, or applications. All Haskell compilers support Haskell 98, so professioanls and educators have a stable base for their work.}},
    author = {Peyton Jones, Simon L.},
    citeulike-article-id = {1643124},
    citeulike-linkout-0 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20&amp;path=ASIN/0521826144},
    citeulike-linkout-1 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21&amp;path=ASIN/0521826144},
    citeulike-linkout-10 = {http://www.worldcat.org/oclc/51271691},
    citeulike-linkout-2 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21&amp;path=ASIN/0521826144},
    citeulike-linkout-3 = {http://www.amazon.jp/exec/obidos/ASIN/0521826144},
    citeulike-linkout-4 = {http://www.amazon.co.uk/exec/obidos/ASIN/0521826144/citeulike00-21},
    citeulike-linkout-5 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20&path=ASIN/0521826144},
    citeulike-linkout-6 = {http://www.worldcat.org/isbn/0521826144},
    citeulike-linkout-7 = {http://books.google.com/books?vid=ISBN0521826144},
    citeulike-linkout-8 = {http://www.amazon.com/gp/search?keywords=0521826144&index=books&linkCode=qs},
    citeulike-linkout-9 = {http://www.librarything.com/isbn/0521826144},
    day = {05},
    howpublished = {Hardcover},
    isbn = {0521826144},
    keywords = {haskell},
    month = may,
    posted-at = {2013-09-16 18:51:25},
    priority = {2},
    publisher = {Cambridge University Press},
    title = {Haskell 98 language and libraries : the revised report},
    url = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20&path=ASIN/0521826144},
    year = {2003}
}

@article{mcbride:viewfromleft,
    abstract = {Pattern matching has proved an extremely powerful and durable notion in functional programming. This paper contributes a new programming notation for type theory which elaborates the notion in various ways. First, as is by now quite well-known in the type theory community, definition by pattern matching becomes a more discriminating tool in the presence of dependent types, since it refines the explanation of types as well as values. This becomes all the more true in the presence of the rich class of datatypes known as inductive families (Dybjer, 1991). Secondly, as proposed by Peyton Jones (1997) for Haskell, and independently rediscovered by us, subsidiary case analyses on the results of intermediate computations, which commonly take place on the right-hand side of definitions by pattern matching, should rather be handled on the left. In simply-typed languages, this subsumes the trivial case of Boolean guards; in our setting it becomes yet more powerful. Thirdly, elementary pattern matching decompositions have a well-defined interface given by a dependent type; they correspond to the statement of an induction principle for the datatype. More general, user-definable decompositions may be defined which also have types of the same general form. Elementary pattern matching may therefore be recast in abstract form, with a semantics given by translation. Such abstract decompositions of data generalize Wadler's (1987) notion of 'view'. The programmer wishing to introduce a new view of a type \$\mathit{T}\$, and exploit it directly in pattern matching, may do so via a standard programming idiom. The type theorist, looking through the Curry–Howard lens, may see this as proving a theorem, one which establishes the validity of a new induction principle for \$\mathit{T}\$. We develop enough syntax and semantics to account for this high-level style of programming in dependent type theory. We close with the development of a typechecker for the simply-typed lambda calculus, which furnishes a view of raw terms as either being well-typed, or containing an error. The implementation of this view is ipso facto a proof that typechecking is decidable.},
    address = {New York, NY, USA},
    author = {McBride, Conor and McKinna, James},
    citeulike-article-id = {271357},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=967496},
    citeulike-linkout-1 = {http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=192403},
    citeulike-linkout-2 = {http://dx.doi.org/10.1017/s0956796803004829},
    doi = {10.1017/s0956796803004829},
    issn = {0956-7968},
    journal = {J. Funct. Program.},
    keywords = {dependent, pattern-matching, pie, types},
    month = jan,
    number = {1},
    pages = {69--111},
    posted-at = {2013-09-16 15:35:18},
    priority = {2},
    publisher = {Cambridge University Press},
    title = {The view from the left},
    url = {http://dx.doi.org/10.1017/s0956796803004829},
    volume = {14},
    year = {2004}
}

@inproceedings{brady:idris-plpv11,
    abstract = {Dependent types have emerged in recent years as a promising approach to ensuring program correctness. However, existing dependently typed languages such as Agda and Coq work at a very high level of abstraction, making it difficult to map verified programs to suitably efficient executable code. This is particularly problematic for programs which work with bit level data, e.g. network packet processing, binary file formats or operating system services. Such programs, being fundamental to the operation of computers in general, may stand to benefit significantly from program verification techniques. This paper describes the use of a dependently typed programming language, Idris, for specifying and verifying properties of low-level systems programs, taking network packet processing as an extended example. We give an overview of the distinctive features of Idris which allow it to interact with external systems code, with precise types. Furthermore, we show how to integrate tactic scripts and plugin decision procedures to reduce the burden of proof on application developers. The ideas we present are readily adaptable to languages with related type systems.},
    address = {New York, NY, USA},
    author = {Brady, Edwin C.},
    booktitle = {Proceedings of the 5th ACM workshop on Programming languages meets program verification},
    citeulike-article-id = {11841297},
    citeulike-linkout-0 = {http://portal.acm.org/citation.cfm?id=1929529.1929536},
    citeulike-linkout-1 = {http://dx.doi.org/10.1145/1929529.1929536},
    doi = {10.1145/1929529.1929536},
    isbn = {978-1-4503-0487-0},
    keywords = {dependent, functional, idris, programming, types},
    location = {Austin, Texas, USA},
    pages = {43--54},
    posted-at = {2013-09-16 15:34:51},
    priority = {5},
    publisher = {ACM},
    series = {PLPV '11},
    title = {{IDRIS} ---: systems programming meets full dependent types},
    url = {http://dx.doi.org/10.1145/1929529.1929536},
    year = {2011}
}

@misc{spj:awkward,
    abstract = {Functional programming may be beautiful, but to write real applications we must grapple

with awkward real-world issues: input/output, robustness, concurrency, and interfacing to

programs written in other languages.},
    author = {Jones, Simon P.},
    citeulike-article-id = {1102243},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.9123},
    keywords = {haskell, monads, semantics, types},
    posted-at = {2013-09-16 15:28:39},
    priority = {5},
    title = {Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.9123}
}

